# 08. Context API

## 1) 전역 상태 관리 개념

### 왜 Context인가?

* 컴포넌트 트리 깊숙한 곳까지 동일한 정보를 **광범위하게 공유**할 때 유용합니다.
  (예: **테마(다크/라이트)**, **로그인 사용자 정보**, **언어/지역화**, **Feature Flag** 등)
* `props drilling`(중간 컴포넌트가 쓰지도 않는 props를 계속 내려주는 현상)을 완화합니다.

### Context의 특징

* **전역**처럼 보이지만, 실제론 **Provider로 둘러싼 서브트리**에만 적용됩니다.
* **Provider 값이 바뀌면 해당 Context를 구독하는 컴포넌트가 전부 리렌더**됩니다.
  → 성능 이슈가 있을 땐 **컨텍스트 분리(State/Dispatch 분리)**, **메모이제이션**을 도입합니다.

### 언제 Context vs 외부 상태관리?

* **Context**: UI 전역 설정/경량 공유(낮은 쓰기 빈도, 넓은 읽기 범위)
* **Redux/Zustand** 등: 복잡한 비즈니스 상태, 고빈도 업데이트, 미들웨어/디버깅 도구 필요 시

---

## 2) React Context로 상태 공유 — 설계 포인트

1. **도메인 모델링**: `Theme = 'light' | 'dark' | 'system'`

   * `option`: 사용자가 선택한 옵션
   * `effective`: 실제로 적용된 테마(시스템 연동 시 ‘system’이 ‘light’/‘dark’ 중 하나로 해석됨)
2. **Reducer + Context**:

   * `useReducer`로 상태 전이를 명시
   * **StateContext**와 **DispatchContext**를 분리해 **불필요한 리렌더** 최소화
3. **부작용 관리**:

   * `localStorage`에 사용자 옵션 저장
   * `[data-theme="dark"]` 속성으로 전역 스타일 스위치
   * `prefers-color-scheme` 미디어쿼리 구독

---

## 3) 실습: 다크모드 전환

### 3-1) 프로젝트 초기화 (Vite)

```bash
npm create vite@latest react-context-theme-ts -- --template react-swc-ts
cd react-context-theme-ts
npm install
npm run dev
```

### 3-2) 폴더 구조

```
src/
├─ App.tsx
├─ main.tsx
├─ index.css
├─ context/
│  └─ ThemeContext.tsx
└─ components/
   ├─ ThemeToggle.tsx
   └─ DemoCard.tsx
```

---

### 3-3) 전역 스타일(다크/라이트 토큰)

**`src/index.css`**

```css
:root {
  --bg: #ffffff;
  --fg: #111827;
  --muted: #6b7280;
  --card: #ffffff;
  --border: #e5e7eb;
}

:root[data-theme="dark"] {
  --bg: #0b0f14;
  --fg: #e5e7eb;
  --muted: #9ca3af;
  --card: #0f1720;
  --border: #1f2937;
}

/* 접근성: OS 테마에 맞춘 폼 컨트롤/스크롤바 */
:root {
  color-scheme: light;
}
:root[data-theme="dark"] {
  color-scheme: dark;
}

html, body, #root {
  height: 100%;
}
body {
  margin: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
  line-height: 1.5;
}

.card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 16px;
}

.small {
  color: var(--muted);
  font-size: 12px;
}
```

---

### 3-4) Theme Context (State/Dispatch 분리 + 로컬 스토리지 + 시스템 연동)

**`src/context/ThemeContext.tsx`**

```tsx
import { createContext, useCallback, useContext, useEffect, useMemo, useReducer } from 'react';

export type ThemeOption = 'light' | 'dark' | 'system';
export type EffectiveTheme = 'light' | 'dark';

type ThemeState = {
  option: ThemeOption;      // 사용자가 고른 옵션
  effective: EffectiveTheme; // 실제 적용 테마 (system → light/dark로 해석)
};

type Action =
  | { type: 'SET_OPTION'; option: ThemeOption }
  | { type: 'SYSTEM_CHANGED'; system: EffectiveTheme };

const THEME_KEY = 'app.theme.option';

function getSystemTheme(): EffectiveTheme {
  if (typeof window === 'undefined') return 'light';
  return window.matchMedia?.('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
}

function getInitialOption(): ThemeOption {
  try {
    const saved = localStorage.getItem(THEME_KEY) as ThemeOption | null;
    return saved ?? 'system';
  } catch {
    return 'system';
  }
}

function computeEffective(option: ThemeOption): EffectiveTheme {
  return option === 'system' ? getSystemTheme() : option;
}

function reducer(state: ThemeState, action: Action): ThemeState {
  switch (action.type) {
    case 'SET_OPTION': {
      const nextEff = computeEffective(action.option);
      return { option: action.option, effective: nextEff };
    }
    case 'SYSTEM_CHANGED': {
      if (state.option !== 'system') return state;
      return { ...state, effective: action.system };
    }
    default:
      return state;
  }
}

/** Context 분리: 상태와 디스패치를 각각 제공 */
const ThemeStateContext = createContext<ThemeState | null>(null);
const ThemeDispatchContext = createContext<React.Dispatch<Action> | null>(null);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const initialOption = getInitialOption();
  const [state, dispatch] = useReducer(reducer, {
    option: initialOption,
    effective: computeEffective(initialOption),
  });

  /** DOM에 data-theme 반영 + 옵션 영속화 */
  useEffect(() => {
    document.documentElement.setAttribute('data-theme', state.effective);
  }, [state.effective]);

  useEffect(() => {
    try {
      localStorage.setItem(THEME_KEY, state.option);
    } catch {}
  }, [state.option]);

  /** 시스템 테마 변화 감지 (option === 'system'일 때만) */
  useEffect(() => {
    const mql = window.matchMedia?.('(prefers-color-scheme: dark)');
    if (!mql) return;

    const handler = (e: MediaQueryListEvent) =>
      dispatch({ type: 'SYSTEM_CHANGED', system: e.matches ? 'dark' : 'light' });

    if (state.option === 'system') {
      mql.addEventListener('change', handler);
      return () => mql.removeEventListener('change', handler);
    }
  }, [state.option]);

  /** 편의 메서드: 토글/명시적 설정 */
  const setOption = useCallback((option: ThemeOption) => {
    dispatch({ type: 'SET_OPTION', option });
  }, []);
  const toggle = useCallback(() => {
    const next = state.effective === 'dark' ? 'light' : 'dark';
    dispatch({ type: 'SET_OPTION', option: next });
  }, [state.effective]);

  /** value 메모이제이션 (참조 안정성) */
  const stateValue = useMemo(() => state, [state]);
  const dispatchValue = useMemo(
    () => ({ dispatch, setOption, toggle }),
    [dispatch, setOption, toggle]
  );

  return (
    <ThemeStateContext.Provider value={stateValue}>
      <ThemeDispatchContext.Provider value={dispatch as React.Dispatch<Action> & any}>
        {/* 위 Provider에 메서드를 포함시키지 않아, 상태 변경 시 불필요한 재생성 최소화 */}
        <ThemeMethodsContext.Provider value={{ setOption, toggle }}>
          {children}
        </ThemeMethodsContext.Provider>
      </ThemeDispatchContext.Provider>
    </ThemeStateContext.Provider>
  );
}

/** 읽기 전용 상태 */
export function useThemeState(): ThemeState {
  const ctx = useContext(ThemeStateContext);
  if (!ctx) throw new Error('useThemeState must be used within ThemeProvider');
  return ctx;
}

/** 액션 메서드 전용 컨텍스트 (State와 분리) */
const ThemeMethodsContext = createContext<{ setOption: (o: ThemeOption) => void; toggle: () => void } | null>(null);
export function useThemeActions() {
  const ctx = useContext(ThemeMethodsContext);
  if (!ctx) throw new Error('useThemeActions must be used within ThemeProvider');
  return ctx;
}

/** 합쳐서 쓰고 싶다면 */
export function useTheme() {
  return { ...useThemeState(), ...useThemeActions() };
}
```

> 포인트
>
> * **State/Dispatch/Methods 분리**로 **필요한 것만 구독** → 리렌더 최소화
> * `option==='system'`일 때만 `matchMedia` 구독
> * `document.documentElement`에 `data-theme` 속성 적용 → CSS 변수 전역 스위치

---

### 3-5) 토글 컴포넌트 & 데모 카드

**`src/components/ThemeToggle.tsx`**

```tsx
import { useTheme } from '../context/ThemeContext';

export default function ThemeToggle() {
  const { option, effective, setOption, toggle } = useTheme();
  return (
    <div className="card" style={{ display: 'grid', gap: 8 }}>
      <strong>Theme</strong>
      <div className="small">option: <code>{option}</code> / effective: <code>{effective}</code></div>

      <div style={{ display: 'flex', gap: 8, flexWrap: 'wrap' }}>
        <button onClick={() => setOption('light')}>Light</button>
        <button onClick={() => setOption('dark')}>Dark</button>
        <button onClick={() => setOption('system')}>System</button>
        <button onClick={toggle} style={{ marginLeft: 'auto' }}>Toggle</button>
      </div>
    </div>
  );
}
```

**`src/components/DemoCard.tsx`**

```tsx
export default function DemoCard() {
  return (
    <div className="card" style={{ display: 'grid', gap: 6 }}>
      <strong>카드 컴포넌트</strong>
      <p className="small">전역 테마 변수로 배경/텍스트/보더 색상이 바뀝니다.</p>
      <div style={{ display: 'flex', gap: 8 }}>
        <button>확인</button>
        <button>취소</button>
      </div>
    </div>
  );
}
```

---

### 3-6) App & 진입점

**`src/App.tsx`**

```tsx
import { ThemeProvider } from './context/ThemeContext';
import ThemeToggle from './components/ThemeToggle';
import DemoCard from './components/DemoCard';

export default function App() {
  return (
    <ThemeProvider>
      <main style={{ maxWidth: 800, margin: '0 auto', padding: 24, display: 'grid', gap: 16 }}>
        <h1>08. Context API — 다크모드 전환</h1>
        <ThemeToggle />
        <div style={{ display: 'grid', gap: 12 }}>
          <DemoCard />
          <DemoCard />
        </div>
      </main>
    </ThemeProvider>
  );
}
```

**`src/main.tsx`**

```tsx
import { createRoot } from 'react-dom/client';
import App from './App';
import './index.css';

createRoot(document.getElementById('root')!).render(<App />);
```

> 실행하면 **System/Light/Dark**를 전환할 때, 문서 루트의 `data-theme`와 **CSS 변수**가 바뀌며 UI 전체가 스위치됩니다.

---

## 4) 실습 미션 (Hands-on)

1. **키보드 단축키 추가**

   * `Ctrl/Cmd + J` 누르면 `toggle()` 실행.
   * 전역 리스너는 `useEffect` + cleanup으로 관리(Provider 상단에서).

2. **Context 분할 체감**

   * `ThemeProvider`에서 `state`와 `methods`를 **각각 다른 컨텍스트**로 노출하는 현재 구조를 유지한 채,
     `DemoCard`는 **상태만**, `ThemeToggle`은 **상태+메서드**를 구독하도록 유지 → 리렌더 차이 관찰.

3. **초기 테마 깜빡임(FOUC) 제거**

   * `index.html`에 인라인 스크립트로 `localStorage` 값을 읽어 **최초 페인트 전** `data-theme`를 세팅.

4. **다양한 도메인 추가**

   * `LocaleContext`(ko/en) 또는 `AuthContext`(user/null) 추가 → 다중 Provider 구성 연습.

5. **Tailwind 연동(선택)**

   * Tailwind 사용 시, `:root[data-theme="dark"]`와 함께 `dark:` 프리픽스를 병행하여 토큰/유틸 혼합 전략을 시도.

---

## 5) 자주 하는 실수 & 베스트 프랙티스

* **Provider 값 객체 매 렌더 재생성**: `useMemo`로 감싸 참조 안정화.
* **모든 걸 Context로**: 고빈도 업데이트(스크롤 위치 등)는 Context 대상 아님. 로컬 state/별도 스토어 고려.
* **단일 Context에 너무 많은 값**: **도메인별로 분리**하거나 **State/Dispatch 분리**로 리렌더 범위를 줄이기.
* **초기 깜빡임**: 최초 페인트 전에 테마를 세팅하거나 CSS의 `transition`을 지연.

---

## 6) 예상 질문(Q\&A)

**Q1. Context 업데이트가 느려요. 어떻게 최적화하죠?**
A. (1) **State/Dispatch 분리** (지금 예제 구조), (2) Provider 값을 **useMemo**로 고정,
(3) 큰 리스트는 Context 대신 **props로 필요한 데이터만** 전달, (4) 필요 시 **컨텍스트 셀렉터**(예: `use-context-selector`) 도입.

**Q2. Redux/Zustand 대신 Context만으로 충분할까요?**
A. 단순 전역 설정/사용자 정보 공유에는 충분합니다. **서버 캐시/복잡한 비즈니스 로직/미들웨어**가 필요하면 전용 스토어를 고려하세요.

**Q3. ‘system’ 옵션에서 OS 테마가 바뀌면 자동으로 반영되나요?**
A. 네. `matchMedia('(prefers-color-scheme: dark)')`를 구독하여 **실시간으로 `effective`를 업데이트**합니다.

**Q4. SSR(Next.js)에서도 같은 방식으로 하면 되나요?**
A. SSR 환경에선 `window`가 없으므로 **초기값 계산 시 분기 처리**가 필요합니다. 또한 **클라이언트 하이드레이션 이전** 테마를 맞추기 위해 `_document`에서 초기 `data-theme`를 설정합니다.

**Q5. Context를 테스트하려면?**
A. 테스트에서 **Provider로 감싸고** 훅은 **커스텀 렌더링 함수**(Testing Library)로 주입합니다. 상태 전이는 reducer 단위로 **순수 함수 테스트**가 가능합니다.

