# 14. API Routes

## 1) Next.js API 라우트 개념

### 무엇을 해결하나?

* **클라이언트와 같은 리포지토리**에서 간단한 \*\*백엔드(서버리스 함수)\*\*를 구현할 수 있습니다.
* 파일 위치: `pages/api/**`. 파일 경로가 **HTTP 경로**가 됩니다.
  예) `pages/api/posts/index.ts` → `GET/POST /api/posts`
* 실행 환경: **서버에서만 동작**(브라우저 번들에 포함되지 않음).
  → 토큰/비밀 키를 안전하게 사용 가능.
* 용도: 폼 제출, 간단한 CRUD, 프록시(서드파티 API 키 숨기기), 웹훅 등.
* 한계: 무상태(stateless) 함수 성격. 메모리 저장소는 **배포 환경**에서 지속되지 않을 수 있음(학습/로컬에는 충분).

> 이번 실습은 **간단한 REST API**(posts)와, 이를 호출하는 **페이지**를 함께 구현합니다.

---

## 2) 프로젝트 생성 (TypeScript + Pages Router)

```bash
npx create-next-app@latest next-api-ts --ts --no-app
cd next-api-ts
npm run dev
# http://localhost:3000
```

디렉터리(일부):

```
next-api-ts/
├─ pages/
│  ├─ index.tsx
│  └─ api/
│     └─ ... (여기에 API 파일 작성)
├─ lib/
│  └─ db.ts   (데모용 인메모리 DB)
└─ ...
```

---

## 3) 서버 없는 백엔드 만들기 — 인메모리 DB + REST 엔드포인트

### 3-1) 타입과 인메모리 “DB”

**`lib/db.ts`**

```ts
export type Post = {
  id: string;
  title: string;
  body: string;
  createdAt: number;
  updatedAt: number;
};

declare global {
  // dev 핫리로드에도 데이터 유지(서버 프로세스 내)
  // 배포(서버리스)에서는 보장되지 않음: 학습용
  // eslint-disable-next-line no-var
  var __POSTS__: Post[] | undefined;
}

const store: Post[] = global.__POSTS__ ?? [
  {
    id: 'p1',
    title: '첫 글',
    body: 'Next.js API Routes 시작!',
    createdAt: Date.now(),
    updatedAt: Date.now(),
  },
];
global.__POSTS__ = store;

export const db = {
  all(): Post[] {
    // 최신순
    return [...store].sort((a, b) => b.createdAt - a.createdAt);
  },
  get(id: string): Post | undefined {
    return store.find((p) => p.id === id);
  },
  create(input: Pick<Post, 'title' | 'body'>): Post {
    const now = Date.now();
    const post: Post = {
      id: crypto.randomUUID(),
      title: input.title,
      body: input.body,
      createdAt: now,
      updatedAt: now,
    };
    store.unshift(post);
    return post;
  },
  update(id: string, patch: Partial<Pick<Post, 'title' | 'body'>>): Post | undefined {
    const target = store.find((p) => p.id === id);
    if (!target) return;
    if (patch.title !== undefined) target.title = patch.title;
    if (patch.body !== undefined) target.body = patch.body;
    target.updatedAt = Date.now();
    return target;
  },
  remove(id: string): boolean {
    const i = store.findIndex((p) => p.id === id);
    if (i < 0) return false;
    store.splice(i, 1);
    return true;
  },
};
```

### 3-2) 헬스 체크(기본 확인)

**`pages/api/health.ts`**

```ts
import type { NextApiRequest, NextApiResponse } from 'next';

export default function handler(_req: NextApiRequest, res: NextApiResponse) {
  res.status(200).json({ ok: true, ts: Date.now() });
}
```

→ 브라우저에서 `/api/health`로 확인.

### 3-3) 리스트 & 생성: `GET/POST /api/posts`

**`pages/api/posts/index.ts`**

```ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { db } from '../../../lib/db';

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'GET') {
    const q = String(req.query.q ?? '').toLowerCase();
    const data = db.all().filter(p =>
      !q || p.title.toLowerCase().includes(q) || p.body.toLowerCase().includes(q)
    );
    return res.status(200).json({ items: data });
  }

  if (req.method === 'POST') {
    try {
      const { title, body } = req.body ?? {};
      if (!title || !body) return res.status(400).json({ error: 'title/body는 필수' });
      const created = db.create({ title, body });
      return res.status(201).json(created);
    } catch (e) {
      return res.status(500).json({ error: '서버 오류' });
    }
  }

  res.setHeader('Allow', 'GET, POST');
  return res.status(405).end('Method Not Allowed');
}
```

### 3-4) 단건 조회/수정/삭제: `GET/PUT/DELETE /api/posts/[id]`

**`pages/api/posts/[id].ts`**

```ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { db } from '../../../lib/db';

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const id = String(req.query.id);
  const target = db.get(id);

  if (req.method === 'GET') {
    if (!target) return res.status(404).json({ error: 'not found' });
    return res.status(200).json(target);
  }

  if (req.method === 'PUT') {
    if (!target) return res.status(404).json({ error: 'not found' });
    const { title, body } = req.body ?? {};
    if (title === undefined && body === undefined) {
      return res.status(400).json({ error: 'title/body 중 하나는 필요' });
    }
    const updated = db.update(id, { title, body });
    return res.status(200).json(updated);
  }

  if (req.method === 'DELETE') {
    if (!target) return res.status(404).json({ error: 'not found' });
    db.remove(id);
    return res.status(204).end();
  }

  res.setHeader('Allow', 'GET, PUT, DELETE');
  return res.status(405).end('Method Not Allowed');
}
```

---

## 4) 클라이언트 페이지(REST 호출): 목록 + 작성 + 검색 + 삭제

**`pages/index.tsx`**

```tsx
import { FormEvent, useEffect, useMemo, useState } from 'react';

type Post = {
  id: string;
  title: string;
  body: string;
  createdAt: number;
  updatedAt: number;
};

export default function Home() {
  const [items, setItems] = useState<Post[]>([]);
  const [q, setQ] = useState('');
  const [title, setTitle] = useState('');
  const [body, setBody] = useState('');
  const [loading, setLoading] = useState(false);
  const [pending, setPending] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function load() {
    try {
      setLoading(true);
      setError(null);
      const res = await fetch(`/api/posts?q=${encodeURIComponent(q)}`);
      const data = await res.json();
      setItems(data.items);
    } catch (e: any) {
      setError(e.message ?? '불러오기 실패');
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => { load(); /* q 변경마다 */ }, [q]);

  async function onSubmit(e: FormEvent) {
    e.preventDefault();
    setPending(true);
    try {
      const res = await fetch('/api/posts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, body }),
      });
      if (!res.ok) throw new Error('생성 실패');
      setTitle(''); setBody('');
      await load();
    } catch (e: any) {
      alert(e.message ?? '오류');
    } finally {
      setPending(false);
    }
  }

  async function onRemove(id: string) {
    if (!confirm('삭제하시겠어요?')) return;
    await fetch(`/api/posts/${id}`, { method: 'DELETE' });
    await load();
  }

  return (
    <main style={{ maxWidth: 820, margin: '0 auto', padding: 24, display: 'grid', gap: 16 }}>
      <h1>API Routes — 간단한 REST 데모</h1>

      <form onSubmit={onSubmit} style={{ display: 'grid', gap: 8 }} className="card">
        <strong>새 글 작성</strong>
        <input
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          placeholder="제목"
          required
        />
        <textarea
          value={body}
          onChange={(e) => setBody(e.target.value)}
          placeholder="내용"
          rows={3}
          required
        />
        <div style={{ display: 'flex', gap: 8 }}>
          <button type="submit" disabled={pending}>{pending ? '저장 중…' : '저장'}</button>
          <input
            value={q}
            onChange={(e) => setQ(e.target.value)}
            placeholder="검색(제목/내용)"
            style={{ marginLeft: 'auto' }}
          />
        </div>
      </form>

      {loading ? (
        <p>불러오는 중…</p>
      ) : error ? (
        <p style={{ color: 'crimson' }}>{error}</p>
      ) : (
        <ul style={{ listStyle: 'none', padding: 0, display: 'grid', gap: 10 }}>
          {items.map((p) => (
            <li key={p.id} className="card" style={{ display: 'grid', gap: 6 }}>
              <div style={{ display: 'flex', alignItems: 'baseline', gap: 8 }}>
                <strong>{p.title}</strong>
                <small style={{ color: '#6b7280' }}>
                  {new Date(p.createdAt).toLocaleString()}
                </small>
                <button onClick={() => onRemove(p.id)} style={{ marginLeft: 'auto' }}>삭제</button>
              </div>
              <p style={{ margin: 0 }}>{p.body}</p>
            </li>
          ))}
        </ul>
      )}
    </main>
  );
}
```

> 여기까지로 \*\*서버(Next API Routes)\*\*와 **클라이언트 페이지**가 한 프로젝트에서 동작합니다.

---

## 5) 실습 미션 (Hands-on)

1. **수정(EDIT) 기능**

   * 단건 API(`PUT /api/posts/:id`)를 이용해 제목/내용을 수정하는 UI를 추가하세요(인라인 편집 또는 모달).

2. **입력 검증**

   * 서버에서 제목 최소 2자, 내용 최소 5자 검증(400 응답).
   * 클라이언트에서도 동일 규칙을 미리 검증하고 오류 메시지 표시.

3. **페이지네이션**

   * `GET /api/posts?page=1&pageSize=5`를 지원하도록 API 확장 후, 클라이언트에서 페이지 이동 구현.

4. **권한(기본)**

   * `Authorization: Bearer <token>` 헤더가 없으면 `401`. 임시 토큰을 `.env.local`에 두고 서버에서만 비교.

5. **캐시 헤더**

   * `GET /api/posts` 응답에 `Cache-Control: s-maxage=30, stale-while-revalidate=600` 설정(프록시/CDN 캐시 실습).

---

## 6) 자주 하는 실수 & 베스트 프랙티스

* **메모리 저장소 남용**: 학습/로컬은 OK. 배포 환경에서는 DB/외부 스토리지를 사용하세요.
* **HTTP 메서드/상태코드 일관성**: 성공/실패/검증오류 코드(201/200/204/400/401/404/405)를 명확히.
* **비밀키 노출 금지**: 클라이언트에서 비밀을 쓰지 말고 **API Route 내부**에서만 사용.
* **에러 처리**: try/catch로 500/400 구분. 클라이언트는 메시지 노출/재시도 UX를 설계.
* **스키마 검증 도입**(선택): `zod` 같은 라이브러리로 서버/클라이언트 **공유 타입/검증**을 일치시키면 품질↑.

---

## 7) 예상 질문(Q\&A)

**Q1. Pages Router 대신 App Router의 `app/api/**/route.ts`를 써도 되나요?**
A. 가능합니다. App Router에서는 **Route Handlers**(GET/POST 등 함수 export)로 동일 목적을 달성합니다. 본 장은 Pages Router 흐름에 맞춰 진행했습니다.

**Q2. 서버리스라 인메모리 “DB”가 사라지면 어떡하나요?**
A. 실제 서비스에선 \*\*영속 저장소(DB/KV/Blob)\*\*를 사용하세요. 인메모리는 오직 학습/프로토타이핑용입니다.

**Q3. CORS 설정이 필요할 때는?**
A. 같은 Next 앱 내 페이지에서 호출하면 CORS 이슈가 없습니다. **외부 도메인**에서 호출하려면 헤더(`Access-Control-Allow-*`)를 직접 설정하세요.

**Q4. 속도 최적화는 어떻게?**
A. 읽기 위주라면 **캐싱 헤더** 또는 **ISR/Edge**(App Router)로, 쓰기/권한이 크면 **SSR + 캐시 무효화** 패턴을 검토합니다.

**Q5. 로깅/모니터링은?**
A. 간단히는 `console.log`, 실제 운영은 APM/로그 수집(예: Datadog, Sentry) 연동을 권장합니다.

---

## (부록) Vite(React) 대체 실습 — “API Routes” 느낌 내기

> Next.js 없이 Vite 환경에서 **비슷한 개발 경험**을 원한다면, 프론트는 Vite, 백엔드는 **가벼운 Express**를 같은 리포에 두고 **프록시**로 묶습니다.

1. Vite 앱 만들기

```bash
npm create vite@latest react-api-like -- --template react-swc-ts
cd react-api-like
npm i express
npm i -D @types/express
```

2. 간단 서버 작성
   **`server/index.ts`**

```ts
import express from 'express';
const app = express();
app.use(express.json());

type Post = { id: string; title: string; body: string; createdAt: number; updatedAt: number; };
const store: Post[] = [];

app.get('/api/health', (_req, res) => res.json({ ok: true }));
app.get('/api/posts', (req, res) => {
  const q = String(req.query.q ?? '').toLowerCase();
  const items = store.filter(p => !q || p.title.toLowerCase().includes(q) || p.body.toLowerCase().includes(q));
  res.json({ items });
});
app.post('/api/posts', (req, res) => {
  const { title, body } = req.body ?? {};
  if (!title || !body) return res.status(400).json({ error: 'title/body required' });
  const now = Date.now();
  const post: Post = { id: crypto.randomUUID(), title, body, createdAt: now, updatedAt: now };
  store.unshift(post);
  res.status(201).json(post);
});

const port = 5174; // 예시
app.listen(port, () => console.log('API on http://localhost:' + port));
```

3. Vite 프록시 설정
   **`vite.config.ts`**

```ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react-swc';

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api': 'http://localhost:5174', // 프론트에서 /api로 호출 → 서버로 프록시
    },
  },
});
```

4. 프론트 코드에서는 **Next.js 예제와 동일하게** `/api/**`로 호출하면 됩니다.
   (두 프로세스 동시 실행: `concurrently` 등을 사용하거나 터미널 2개로 각각 `npm run dev` / `ts-node server/index.ts`)

> 결론: **Next.js API Routes**는 “서버 없는 백엔드”를 가장 간단히 붙이는 방법입니다. Vite 환경에서는 **프록시된 경량 서버**로 유사한 개발 경험을 재현할 수 있습니다.

