# 10. 외부 상태 관리

구성: **설명 → 실습 코드(TypeScript, Vite) → 실습 미션 → 예상 질문(Q\&A)**
요구사항: **Vite 초기화**, 예제는 **React + TypeScript** 기준.
(두 가지 해법을 나란히 학습합니다: **Redux Toolkit(표준/툴링 강력)** vs **Zustand(가벼움/간결)**)

---

## 1) 개념 정리 — Redux Toolkit vs Zustand

* **Redux Toolkit(RTK)**

  * 표준화된 보일러플레이트(immer, thunk 기본 포함), **DevTools/미들웨어/비동기 플로우**에 강함.
  * 팀 규모↑, **감사/타임트래블/액션 로깅** 필요, 복잡한 비즈니스 로직 → RTK 권장.

* **Zustand**

  * **아주 가볍고 심플**. 보일러플레이트 최소.
  * 작은 전역 상태, **학습/프로토타이핑/간단 앱** → Zustand 선호.

> 실습 목표
>
> 1. 전역 **카운터**(증가/감소/리셋)
> 2. 전역 **인증 흐름**(로그인/로그아웃, 토큰 보관, 로딩/에러 상태)

---

## 2) 프로젝트 초기화 & 공통 의존성

```bash
# Vite + React + TS
npm create vite@latest state-lab -- --template react-swc-ts
cd state-lab
npm i
npm run dev
```

### 각 상태관리 라이브러리 설치

```bash
# 옵션 A: Redux Toolkit
npm i @reduxjs/toolkit react-redux

# 옵션 B: Zustand
npm i zustand
```

### 공통: 모의 인증 API

```
src/
├─ lib/
│  └─ auth.ts
└─ index.css ...
```

**`src/lib/auth.ts`**

```ts
export type User = { id: string; name: string };
export type LoginInput = { username: string; password: string };

function delay(ms: number) { return new Promise(res => setTimeout(res, ms)); }

export async function loginApi({ username, password }: LoginInput) {
  await delay(600);
  if (!username || !password) throw new Error('아이디/비밀번호를 입력하세요.');
  // 데모: 아무 값이나 통과. 실제로는 서버 요청/검증.
  return {
    token: `mock.${btoa(username)}.${Date.now()}`,
    user: { id: 'u1', name: username } as User
  };
}

export async function logoutApi() {
  await delay(200);
  return true;
}
```

---

## 3) 옵션 A — **Redux Toolkit** 구현

폴더 구조(예시)

```
src/
├─ store/
│  ├─ index.ts         # store 설정 + preloadedState
│  ├─ hooks.ts         # useAppDispatch/useAppSelector
│  ├─ counterSlice.ts
│  └─ authSlice.ts
├─ components/
│  ├─ CounterRedux.tsx
│  └─ AuthRedux.tsx
├─ AppRedux.tsx
└─ main.tsx
```

### 3-1) counterSlice

**`src/store/counterSlice.ts`**

```ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

type CounterState = { value: number };
const initialState: CounterState = { value: 0 };

const counterSlice = createSlice({
  name: 'counter',
  initialState,
  reducers: {
    increment: (s) => { s.value += 1; },
    decrement: (s) => { s.value = Math.max(0, s.value - 1); },
    addBy: (s, a: PayloadAction<number>) => { s.value += a.payload; },
    reset: () => initialState,
  }
});

export const { increment, decrement, addBy, reset } = counterSlice.actions;
export default counterSlice.reducer;
```

### 3-2) authSlice (비동기: createAsyncThunk)

**`src/store/authSlice.ts`**

```ts
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { loginApi, logoutApi, type User, type LoginInput } from '../lib/auth';

type Status = 'idle' | 'loading' | 'error';
type AuthState = {
  token: string | null;
  user: User | null;
  status: Status;
  error?: string;
};

const initialState: AuthState = { token: null, user: null, status: 'idle' };

export const loginThunk = createAsyncThunk(
  'auth/login',
  async (input: LoginInput, { rejectWithValue }) => {
    try { return await loginApi(input); }
    catch (e: any) { return rejectWithValue(e.message ?? '로그인 실패'); }
  }
);

export const logoutThunk = createAsyncThunk('auth/logout', async () => {
  await logoutApi();
  return true;
});

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    hydrate(state, { payload }: { payload: { token: string; user: User } }) {
      state.token = payload.token;
      state.user = payload.user;
      state.status = 'idle';
      state.error = undefined;
    },
    clear(state) {
      state.token = null; state.user = null; state.status = 'idle'; state.error = undefined;
    }
  },
  extraReducers: (b) => {
    b.addCase(loginThunk.pending, (s) => { s.status = 'loading'; s.error = undefined; });
    b.addCase(loginThunk.fulfilled, (s, a) => {
      s.status = 'idle'; s.token = a.payload.token; s.user = a.payload.user;
    });
    b.addCase(loginThunk.rejected, (s, a) => {
      s.status = 'error'; s.error = String(a.payload ?? a.error.message ?? '오류');
    });
    b.addCase(logoutThunk.fulfilled, (s) => {
      s.token = null; s.user = null; s.status = 'idle'; s.error = undefined;
    });
  }
});

export const { hydrate, clear } = authSlice.actions;
export default authSlice.reducer;
```

### 3-3) store/index + 로컬스토리지 영속화(간단)

**`src/store/index.ts`**

```ts
import { configureStore } from '@reduxjs/toolkit';
import counter from './counterSlice';
import auth, { hydrate } from './authSlice';

const KEY = 'state.auth';

function loadAuth() {
  try {
    const raw = localStorage.getItem(KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (parsed?.token && parsed?.user) return parsed;
  } catch {}
  return null;
}

export const store = configureStore({
  reducer: { counter, auth },
  // preloadedState를 auth만 복원해도 되지만, 더 간단히 run 후 hydrate 디스패치
});

const restored = loadAuth();
if (restored) store.dispatch(hydrate(restored));

store.subscribe(() => {
  const s = store.getState();
  try {
    if (s.auth.token && s.auth.user) {
      localStorage.setItem(KEY, JSON.stringify({ token: s.auth.token, user: s.auth.user }));
    } else {
      localStorage.removeItem(KEY);
    }
  } catch {}
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

**`src/store/hooks.ts`**

```ts
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
import type { RootState, AppDispatch } from './index';
export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
```

### 3-4) UI 컴포넌트(RTK)

**`src/components/CounterRedux.tsx`**

```tsx
import { useAppDispatch, useAppSelector } from '../store/hooks';
import { addBy, decrement, increment, reset } from '../store/counterSlice';
import { useState } from 'react';

export default function CounterRedux() {
  const count = useAppSelector(s => s.counter.value);
  const dispatch = useAppDispatch();
  const [step, setStep] = useState(1);

  return (
    <div className="card" style={{ display: 'grid', gap: 8 }}>
      <strong>Redux Counter</strong>
      <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
        <button onClick={() => dispatch(decrement())}>-</button>
        <span style={{ minWidth: 40, textAlign: 'center' }}>{count}</span>
        <button onClick={() => dispatch(increment())}>+</button>
        <button onClick={() => dispatch(reset())}>reset</button>
      </div>
      <div style={{ display: 'flex', gap: 8 }}>
        <input type="number" value={step} onChange={e => setStep(Number(e.target.value) || 0)} style={{ width: 80 }} />
        <button onClick={() => dispatch(addBy(step))}>+{step}</button>
      </div>
    </div>
  );
}
```

**`src/components/AuthRedux.tsx`**

```tsx
import { useState } from 'react';
import { useAppDispatch, useAppSelector } from '../store/hooks';
import { loginThunk, logoutThunk } from '../store/authSlice';

export default function AuthRedux() {
  const { token, user, status, error } = useAppSelector(s => s.auth);
  const dispatch = useAppDispatch();
  const [username, setUsername] = useState('admin');
  const [password, setPassword] = useState('pass');

  const login = () => dispatch(loginThunk({ username, password }));
  const logout = () => dispatch(logoutThunk());

  return (
    <div className="card" style={{ display: 'grid', gap: 8 }}>
      <strong>Redux Auth</strong>
      {token ? (
        <>
          <div>안녕하세요, <b>{user?.name}</b> 님!</div>
          <small>token: <code>{token.slice(0, 16)}...</code></small>
          <div><button onClick={logout}>로그아웃</button></div>
        </>
      ) : (
        <>
          <input placeholder="username" value={username} onChange={e => setUsername(e.target.value)} />
          <input placeholder="password" type="password" value={password} onChange={e => setPassword(e.target.value)} />
          <button onClick={login} disabled={status === 'loading'}>{status === 'loading' ? '로그인 중…' : '로그인'}</button>
          {status === 'error' && <div style={{ color: 'crimson' }}>{error}</div>}
        </>
      )}
    </div>
  );
}
```

### 3-5) AppRedux & main

**`src/AppRedux.tsx`**

```tsx
import CounterRedux from './components/CounterRedux';
import AuthRedux from './components/AuthRedux';

export default function AppRedux() {
  return (
    <main style={{ maxWidth: 800, margin: '0 auto', padding: 24, display: 'grid', gap: 16 }}>
      <h1>전역 상태 — Redux Toolkit</h1>
      <AuthRedux />
      <CounterRedux />
    </main>
  );
}
```

**`src/main.tsx`** (Redux 사용 예)

```tsx
import { createRoot } from 'react-dom/client';
import { Provider } from 'react-redux';
import { store } from './store';
import AppRedux from './AppRedux';
import './index.css';

createRoot(document.getElementById('root')!).render(
  <Provider store={store}>
    <AppRedux />
  </Provider>
);
```

---

## 4) 옵션 B — **Zustand** 구현

폴더 구조(핵심)

```
src/
├─ zustand/
│  └─ store.ts
├─ components/
│  ├─ CounterZ.tsx
│  └─ AuthZ.tsx
└─ AppZustand.tsx
```

### 4-1) store.ts (persist로 자동 로컬스토리지)

**`src/zustand/store.ts`**

```ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { loginApi, logoutApi, type User, type LoginInput } from '../lib/auth';

type AuthSlice = {
  token: string | null;
  user: User | null;
  status: 'idle' | 'loading' | 'error';
  error?: string;
  login: (input: LoginInput) => Promise<void>;
  logout: () => Promise<void>;
};

type CounterSlice = {
  value: number;
  increment: () => void;
  decrement: () => void;
  addBy: (n: number) => void;
  reset: () => void;
};

type Store = AuthSlice & CounterSlice;

export const useStore = create<Store>()(
  persist(
    (set, get) => ({
      // counter
      value: 0,
      increment: () => set((s) => ({ value: s.value + 1 })),
      decrement: () => set((s) => ({ value: Math.max(0, s.value - 1) })),
      addBy: (n) => set((s) => ({ value: s.value + n })),
      reset: () => set(() => ({ value: 0 })),

      // auth
      token: null,
      user: null,
      status: 'idle',
      async login(input) {
        set({ status: 'loading', error: undefined });
        try {
          const { token, user } = await loginApi(input);
          set({ token, user, status: 'idle' });
        } catch (e: any) {
          set({ status: 'error', error: e.message ?? '로그인 실패' });
        }
      },
      async logout() {
        await logoutApi();
        set({ token: null, user: null, status: 'idle', error: undefined });
      },
    }),
    {
      name: 'zustand-auth', // localStorage key
      partialize: (s) => ({ token: s.token, user: s.user }), // auth만 영속
    }
  )
);
```

### 4-2) UI 컴포넌트(Zustand)

**`src/components/CounterZ.tsx`**

```tsx
import { useState } from 'react';
import { useStore } from '../zustand/store';

export default function CounterZ() {
  const { value, increment, decrement, reset, addBy } = useStore(
    s => ({ value: s.value, increment: s.increment, decrement: s.decrement, reset: s.reset, addBy: s.addBy })
  );
  const [step, setStep] = useState(1);

  return (
    <div className="card" style={{ display: 'grid', gap: 8 }}>
      <strong>Zustand Counter</strong>
      <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
        <button onClick={decrement}>-</button>
        <span style={{ minWidth: 40, textAlign: 'center' }}>{value}</span>
        <button onClick={increment}>+</button>
        <button onClick={reset}>reset</button>
      </div>
      <div style={{ display: 'flex', gap: 8 }}>
        <input type="number" value={step} onChange={e => setStep(Number(e.target.value) || 0)} style={{ width: 80 }} />
        <button onClick={() => addBy(step)}>+{step}</button>
      </div>
    </div>
  );
}
```

**`src/components/AuthZ.tsx`**

```tsx
import { useState } from 'react';
import { useStore } from '../zustand/store';

export default function AuthZ() {
  const { token, user, status, error, login, logout } = useStore(
    s => ({ token: s.token, user: s.user, status: s.status, error: s.error, login: s.login, logout: s.logout })
  );
  const [username, setUsername] = useState('admin');
  const [password, setPassword] = useState('pass');

  return (
    <div className="card" style={{ display: 'grid', gap: 8 }}>
      <strong>Zustand Auth</strong>
      {token ? (
        <>
          <div>안녕하세요, <b>{user?.name}</b> 님!</div>
          <small>token: <code>{token.slice(0, 16)}...</code></small>
          <div><button onClick={() => logout()}>로그아웃</button></div>
        </>
      ) : (
        <>
          <input placeholder="username" value={username} onChange={e => setUsername(e.target.value)} />
          <input placeholder="password" type="password" value={password} onChange={e => setPassword(e.target.value)} />
          <button onClick={() => login({ username, password })} disabled={status === 'loading'}>
            {status === 'loading' ? '로그인 중…' : '로그인'}
          </button>
          {status === 'error' && <div style={{ color: 'crimson' }}>{error}</div>}
        </>
      )}
    </div>
  );
}
```

### 4-3) AppZustand

**`src/AppZustand.tsx`**

```tsx
import AuthZ from './components/AuthZ';
import CounterZ from './components/CounterZ';

export default function AppZustand() {
  return (
    <main style={{ maxWidth: 800, margin: '0 auto', padding: 24, display: 'grid', gap: 16 }}>
      <h1>전역 상태 — Zustand</h1>
      <AuthZ />
      <CounterZ />
    </main>
  );
}
```

### 4-4) main.tsx에서 앱 선택 실행

* 지금은 Redux 예제를 기본으로 뒀습니다. **Zustand로 보고 싶으면** 아래처럼 바꿔 실행하세요.

```tsx
// --- Redux 실행 ---
// import { createRoot } from 'react-dom/client';
// import { Provider } from 'react-redux';
// import { store } from './store';
// import AppRedux from './AppRedux';
// import './index.css';
// createRoot(document.getElementById('root')!).render(
//   <Provider store={store}><AppRedux /></Provider>
// );

// --- Zustand 실행 ---
import { createRoot } from 'react-dom/client';
import AppZustand from './AppZustand';
import './index.css';
createRoot(document.getElementById('root')!).render(<AppZustand />);
```

---

## 5) 실습 미션 (Hands-on)

1. **권한 보호 라우팅**

   * “내 정보” 페이지를 만들고 **토큰 없으면 로그인 화면으로 이동**.
   * RTK: `useAppSelector`로 auth 검사, React Router `Navigate` 사용.
   * Zustand: `useStore`로 토큰 검사.

2. **토큰 만료 처리**

   * `setTimeout`으로 10초 후 만료되는 가짜 토큰을 발급하고, 만료 시 자동 로그아웃/갱신 플로우 추가.

3. **비동기 카운터(선택)**

   * 500ms 후 증가하는 `incrementAsync()`를 RTK thunk / Zustand 비동기로 각각 구현.

4. **선택자 최적화**

   * Zustand: `useStore(s => s.value)`처럼 **좁은 선택자**로 리렌더 최소화.
   * RTK: 복잡한 파생값은 `reselect`로 **메모이즈드 셀렉터** 만들어 보기.

5. **Persist 커스터마이즈**

   * RTK: slice별로 `redux-persist` 도입해보기(blacklist/whitelist).
   * Zustand: `partialize`로 영속화할 필드만 저장(이미 적용).

---

## 6) 자주 하는 실수 & 베스트 프랙티스

* **전역 남용 금지**: 로컬 컴포넌트에 충분한 상태는 **로컬 state**로 유지.
* **불변성(특히 Redux)**: RTK는 immer로 안전하지만, **돌연변이 위험**을 줄이는 코딩 습관 유지.
* **선택자 단위 구독(Zustand)**: `useStore()`로 전체를 가져오면 **불필요 렌더**. 필요한 조각만 구독.
* **영속화 범위 최소화**: 토큰/유저 등 꼭 필요한 데이터만 저장.
* **비동기 에러 처리**: status(`idle|loading|error`)를 일관되게 관리하여 UX 품질 확보.

---

## 7) 예상 질문(Q\&A)

**Q1. 우리 팀은 어떤 걸 쓰는 게 좋을까요?**
A. **감사·디버깅·미들웨어**가 중요하고 팀 규모가 크면 **Redux Toolkit**. 화면 상태 몇 개만 공유하고 간결함이 최우선이면 **Zustand**.

**Q2. Zustand도 DevTools가 있나요?**
A. 별도 미들웨어로 연동 가능하지만, RTK만큼 일체화되어 있진 않습니다. 단, **개발 체감 속도/간결함**은 뛰어납니다.

**Q3. 서버 상태는 어디에?**
A. 서버 캐시/동기화는 **TanStack Query(React Query)** 같은 **서버 상태 라이브러리**가 적합합니다. 전역 스토어는 **클라이언트 상태**에 집중하세요.

**Q4. Redux에서 보일러플레이트가 많지 않나요?**
A. RTK는 slice/thunk/immer로 보일러플레이트를 상당히 줄였습니다. 팀 규칙과 코드젠(플랍/템플릿)으로 더 줄일 수 있습니다.

**Q5. 보안상 토큰은 localStorage에 두면 위험하지 않나요?**
A. 실제 서비스에선 **HTTP-only 쿠키** + **CSRF 방어**가 일반적입니다. 본 실습은 학습용 데모이며, 실서비스 설계는 보안 가이드를 따르세요.

---

## 8) 다음 예고

다음 장에서는 **Next.js 기본**으로 넘어가 SSR/SSG/CSR 렌더링 전략과 **API Routes**를 활용한 풀스택 미니 앱을 만들어 봅니다.
