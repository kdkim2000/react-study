# 17. 데이터베이스 연동 (Prisma + SQLite/Postgres)

## 1) 개념 한눈에

* **Prisma**: 타입 안전 ORM.

  * `schema.prisma`로 **모델 정의** → `prisma migrate`로 **DB 스키마 생성/변경** → `@prisma/client`를 통해 **타입 안전 쿼리**.
  * 개발 속도, 타입 안정성, 마이그레이션 추적에 강점.
* **SQLite ↔ Postgres 전환**: 개발 중엔 SQLite(파일 하나). 배포/동시접속/트랜잭션/확장성은 Postgres.
* **구조 제안**

  ```
  auth-board/                 # 하나의 리포
  ├─ server/                  # Express + Prisma(API 서버)
  └─ client/                  # Vite(React) 프런트
  ```

---

## 2) 프로젝트 초기화

### 2-1) Vite 프런트

```bash
# 프런트
npm create vite@latest client -- --template react-swc-ts
cd client && npm i && cd ..
```

### 2-2) Express + Prisma 백엔드

```bash
mkdir server && cd server
npm init -y
npm i express cors zod
npm i -D typescript ts-node-dev @types/node @types/express @types/cors

# Prisma
npm i prisma @prisma/client
npx prisma init --datasource-provider sqlite   # 먼저 SQLite로 시작
```

### 2-3) 공통 개발 스크립트

**server/tsconfig.json**

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "outDir": "dist"
  },
  "include": ["src"]
}
```

**server/package.json (scripts 일부)**

```json
{
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "prisma:studio": "prisma studio",
    "prisma:migrate": "prisma migrate dev --name init",
    "prisma:generate": "prisma generate",
    "seed": "ts-node-dev --transpile-only prisma/seed.ts"
  }
}
```

**client/vite.config.ts** — API 프록시(프런트 → 백엔드)

```ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react-swc';

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api': 'http://localhost:5174' // Express 포트
    }
  }
});
```

---

## 3) Prisma 스키마 & 마이그레이션

**server/prisma/schema.prisma**

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"              // ↔ Postgres 전환 시 "postgresql"
  url      = env("DATABASE_URL")
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(200)
  content   String
  published Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([createdAt(sort: Desc)])
}
```

**server/.env**

```
DATABASE_URL="file:./dev.db"  # SQLite
```

초기 마이그레이션 & 클라이언트 생성:

```bash
cd server
npm run prisma:migrate
npm run prisma:generate
```

(선택) **seed 데이터**

```
server/prisma/seed.ts
```

```ts
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();

async function main() {
  const count = await prisma.post.count();
  if (count === 0) {
    await prisma.post.createMany({
      data: [
        { title: '첫 글', content: 'Prisma + SQLite 시작!', published: true },
        { title: '두 번째 글', content: 'CRUD 게시판 데모', published: true }
      ]
    });
  }
  console.log('Seed done');
}
main().finally(() => prisma.$disconnect());
```

```bash
npm run seed
```

---

## 4) Express API (CRUD + 검색 + 페이지네이션)

```
server/
└─ src/
   ├─ index.ts
   ├─ db.ts
   ├─ posts.router.ts
   └─ validators.ts
```

**server/src/db.ts** — PrismaClient 싱글턴

```ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = global as unknown as { prisma?: PrismaClient };
export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: ['query', 'error', 'warn'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

**server/src/validators.ts** — Zod로 입력검증

```ts
import { z } from 'zod';

export const createPostSchema = z.object({
  title: z.string().min(2).max(200),
  content: z.string().min(5),
  published: z.boolean().optional().default(true),
});
export const updatePostSchema = z.object({
  title: z.string().min(2).max(200).optional(),
  content: z.string().min(5).optional(),
  published: z.boolean().optional(),
});

export const listQuerySchema = z.object({
  q: z.string().optional(),
  cursor: z.string().optional(), // cursor-based pagination
  take: z.coerce.number().min(1).max(50).default(10),
});
```

**server/src/posts.router.ts**

```ts
import { Router } from 'express';
import { prisma } from './db';
import { createPostSchema, updatePostSchema, listQuerySchema } from './validators';

const r = Router();

/** 목록: 검색(q), 커서 페이지네이션(cursor, take) */
r.get('/', async (req, res) => {
  const parsed = listQuerySchema.safeParse(req.query);
  if (!parsed.success) return res.status(400).json(parsed.error.format());
  const { q, cursor, take } = parsed.data;

  const where = q
    ? { OR: [{ title: { contains: q } }, { content: { contains: q } }] }
    : {};

  const items = await prisma.post.findMany({
    where,
    orderBy: { createdAt: 'desc' },
    take: take + 1,
    ...(cursor ? { skip: 1, cursor: { id: Number(cursor) } } : {})
  });

  const hasMore = items.length > take;
  const sliced = hasMore ? items.slice(0, -1) : items;
  const nextCursor = hasMore ? String(sliced[sliced.length - 1].id) : null;

  res.json({ items: sliced, nextCursor });
});

/** 단건 조회 */
r.get('/:id', async (req, res) => {
  const id = Number(req.params.id);
  const found = await prisma.post.findUnique({ where: { id } });
  if (!found) return res.status(404).json({ error: 'not found' });
  res.json(found);
});

/** 생성 */
r.post('/', async (req, res) => {
  const parsed = createPostSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json(parsed.error.format());
  const created = await prisma.post.create({ data: parsed.data });
  res.status(201).json(created);
});

/** 수정 */
r.put('/:id', async (req, res) => {
  const id = Number(req.params.id);
  const parsed = updatePostSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json(parsed.error.format());
  try {
    const updated = await prisma.post.update({ where: { id }, data: parsed.data });
    res.json(updated);
  } catch {
    res.status(404).json({ error: 'not found' });
  }
});

/** 삭제 */
r.delete('/:id', async (req, res) => {
  const id = Number(req.params.id);
  try {
    await prisma.post.delete({ where: { id } });
    res.status(204).end();
  } catch {
    res.status(404).json({ error: 'not found' });
  }
});

export default r;
```

**server/src/index.ts** — 서버 부팅

```ts
import express from 'express';
import cors from 'cors';
import postsRouter from './posts.router';

const app = express();
app.use(cors({ origin: 'http://localhost:5173', credentials: true }));
app.use(express.json());

app.get('/api/health', (_req, res) => res.json({ ok: true }));
app.use('/api/posts', postsRouter);

const PORT = 5174;
app.listen(PORT, () => console.log(`API on http://localhost:${PORT}`));
```

서버 실행:

```bash
cd server
npm run dev
```

---

## 5) 프런트엔드(React + Vite) — CRUD 게시판

```
client/
└─ src/
   ├─ api.ts
   ├─ types.ts
   ├─ App.tsx
   └─ index.css
```

**client/src/types.ts**

```ts
export type Post = {
  id: number;
  title: string;
  content: string;
  published: boolean;
  createdAt: string; // ISO 문자열로 들어옴
  updatedAt: string;
};
export type ListResp = { items: Post[]; nextCursor: string | null };
```

**client/src/api.ts**

```ts
import type { ListResp, Post } from './types';

export async function listPosts(q = '', cursor?: string, take = 10): Promise<ListResp> {
  const params = new URLSearchParams();
  if (q) params.set('q', q);
  if (cursor) params.set('cursor', cursor);
  params.set('take', String(take));
  const r = await fetch(`/api/posts?${params.toString()}`);
  if (!r.ok) throw new Error('list failed');
  return r.json();
}

export async function createPost(input: Pick<Post, 'title' | 'content' | 'published'>) {
  const r = await fetch('/api/posts', {
    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(input)
  });
  if (!r.ok) throw new Error('create failed');
  return r.json() as Promise<Post>;
}

export async function updatePost(id: number, patch: Partial<Pick<Post, 'title' | 'content' | 'published'>>) {
  const r = await fetch(`/api/posts/${id}`, {
    method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(patch)
  });
  if (!r.ok) throw new Error('update failed');
  return r.json() as Promise<Post>;
}

export async function removePost(id: number) {
  const r = await fetch(`/api/posts/${id}`, { method: 'DELETE' });
  if (!r.ok && r.status !== 204) throw new Error('delete failed');
}
```

**client/src/App.tsx**

```tsx
import { useEffect, useMemo, useState } from 'react';
import { createPost, listPosts, removePost, updatePost } from './api';
import type { Post } from './types';
import './index.css';

export default function App() {
  const [items, setItems] = useState<Post[]>([]);
  const [q, setQ] = useState('');
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [published, setPublished] = useState(true);
  const [loading, setLoading] = useState(false);
  const [cursor, setCursor] = useState<string | null>(null);
  const [nextCursor, setNextCursor] = useState<string | null>(null);
  const [editingId, setEditingId] = useState<number | null>(null);

  async function load(reset = false) {
    setLoading(true);
    const cur = reset ? undefined : cursor ?? undefined;
    try {
      const resp = await listPosts(q, cur);
      if (reset) {
        setItems(resp.items);
      } else {
        setItems(prev => [...prev, ...resp.items]);
      }
      setNextCursor(resp.nextCursor);
      setCursor(resp.nextCursor);
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => { setCursor(null); setItems([]); load(true); }, [q]); // 검색어 바뀌면 초기 로드

  async function onCreate() {
    if (!title.trim() || !content.trim()) return alert('제목/내용 입력');
    await createPost({ title, content, published });
    setTitle(''); setContent(''); setPublished(true);
    setCursor(null); setItems([]); await load(true);
  }

  async function onDelete(id: number) {
    if (!confirm('삭제하시겠어요?')) return;
    await removePost(id);
    setItems(prev => prev.filter(p => p.id !== id));
  }

  const editing = useMemo(() => items.find(p => p.id === editingId), [items, editingId]);

  async function onSaveEdit() {
    if (editingId == null) return;
    const t = prompt('새 제목', editing?.title);
    if (!t) return;
    const c = prompt('새 내용', editing?.content);
    if (!c) return;
    const updated = await updatePost(editingId, { title: t, content: c });
    setItems(prev => prev.map(p => (p.id === updated.id ? updated : p)));
    setEditingId(null);
  }

  return (
    <main style={{ maxWidth: 900, margin: '0 auto', padding: 24, display: 'grid', gap: 16 }}>
      <h1>Prisma CRUD 게시판</h1>

      <div className="card" style={{ display: 'grid', gap: 8 }}>
        <strong>새 글</strong>
        <input placeholder="제목" value={title} onChange={e => setTitle(e.target.value)} />
        <textarea placeholder="내용" rows={3} value={content} onChange={e => setContent(e.target.value)} />
        <label style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
          <input type="checkbox" checked={published} onChange={e => setPublished(e.target.checked)} />
          공개
        </label>
        <div style={{ display: 'flex', gap: 8 }}>
          <button onClick={onCreate}>등록</button>
          <input placeholder="검색(제목/내용)" value={q} onChange={e => setQ(e.target.value)} style={{ marginLeft: 'auto' }} />
        </div>
      </div>

      <ul style={{ listStyle: 'none', padding: 0, display: 'grid', gap: 10 }}>
        {items.map(p => (
          <li key={p.id} className="card" style={{ display: 'grid', gap: 6 }}>
            <div style={{ display: 'flex', gap: 8, alignItems: 'baseline' }}>
              <strong>{p.title}</strong>
              <small style={{ color: '#6b7280' }}>
                {new Date(p.createdAt).toLocaleString()} {p.published ? '• 공개' : '• 비공개'}
              </small>
              <div style={{ marginLeft: 'auto', display: 'flex', gap: 6 }}>
                <button onClick={() => setEditingId(p.id)}>수정</button>
                <button onClick={() => onDelete(p.id)}>삭제</button>
              </div>
            </div>
            <p style={{ margin: 0 }}>{p.content}</p>
          </li>
        ))}
      </ul>

      <div style={{ display: 'flex', gap: 8 }}>
        <button disabled={!nextCursor || loading} onClick={() => load(false)}>
          {loading ? '로딩 중…' : nextCursor ? '더 불러오기' : '더 없음'}
        </button>
        {editingId && <button onClick={onSaveEdit}>편집 저장</button>}
      </div>
    </main>
  );
}
```

실행:

```bash
# 터미널 1
cd server && npm run dev
# 터미널 2
cd client && npm run dev
```

`http://localhost:5173` → 게시글 생성/검색/수정/삭제/더보기 동작 확인.

---

## 6) Postgres로 전환(배포 대비)

### 6-1) Postgres 준비 (예: Docker Compose)

`server/docker-compose.yml`

```yaml
version: '3.8'
services:
  db:
    image: postgres:16
    environment:
      POSTGRES_USER: app
      POSTGRES_PASSWORD: app
      POSTGRES_DB: appdb
    ports:
      - "5432:5432"
    volumes:
      - dbdata:/var/lib/postgresql/data
volumes:
  dbdata:
```

```bash
cd server
docker compose up -d
```

### 6-2) Prisma 설정 변경

**server/.env**

```
DATABASE_URL="postgresql://app:app@localhost:5432/appdb?schema=public"
```

**server/prisma/schema.prisma**

```prisma
datasource db { provider = "postgresql" url = env("DATABASE_URL") }
```

변경 반영:

```bash
npm run prisma:migrate   # 마이그레이션 생성/적용
npm run prisma:generate
```

> 주의
>
> * 서버리스/멀티 인스턴스 환경에선 **풀링**(e.g. pgbouncer/Prisma Accelerate) 고려.
> * 인덱스/트랜잭션/제약조건은 Postgres 장점을 활용하세요(예: `@@index`, unique 제약).

---

## 7) 실습 미션 (Hands-on)

1. **페이지네이션 개선**

   * 무한스크롤(IntersectionObserver)로 `nextCursor` 자동 로드.

2. **정렬/필터**

   * `?published=true|false` 쿼리 추가, 서버에서 `where: { published }` 필터.

3. **트랜잭션 도입**

   * 다중 작업을 `prisma.$transaction([ ... ])`로 묶어 원자성 보장.

4. **유효성 강화**

   * 서버 Zod 에러를 프런트에서 예쁘게 표시(필드별 메시지).

5. **권한 추가(선택)**

   * 인증 장(16장)과 결합: 작성자만 수정/삭제. `authorId` 필드 추가, 관계(Relation) 모델링.

6. **배포 준비**

   * 프로덕션 `.env` 분리, CORS 제한, 로깅 레벨 조정, 헬스체크 엔드포인트/프로메테우스 지표 추가.

---

## 8) 자주 하는 실수 & 베스트 프랙티스

* **스키마 변경 관리 소홀** → 모든 변경은 `prisma migrate`로 추적. 수동 DDL 혼용 금지.
* **대용량 목록 느림** → **커서 기반 페이지네이션**(지금 사용)을 유지하고 필요한 인덱스 추가.
* **N+1 접근** → 관계 쿼리는 `include/select`로 필요한 필드만, 또는 `findMany`에 `where` 최적화.
* **타임존/날짜 처리** → DB는 UTC, 표시만 현지 시간.
* **에러 핸들링** → Prisma 코드 `try/catch`로 404/400/500을 명확히 분기.

---

## 9) 예상 질문(Q\&A)

**Q1. SQLite로 개발하다가 Postgres로 바꿔도 되나요?**
A. 네. `provider`와 `DATABASE_URL`만 바꾸고 **마이그레이션 재적용**하면 됩니다. 타입·쿼리는 대부분 그대로 동작합니다.

**Q2. Prisma가 느릴 때는?**
A. ORM 문제라기보다 **쿼리/인덱스/데이터량** 문제일 때가 많습니다. `EXPLAIN ANALYZE`로 병목을 확인하고 적절한 인덱스/where 최적화를 하세요.

**Q3. Prisma Studio로 데이터 수정을 해도 되나요?**
A. 개발/운영툴로 유용합니다. 다만 운영 환경에서는 역할분리·권한·백업 절차를 지키는 게 안전합니다.

**Q4. 게시판에 댓글/태그를 추가하려면?**
A. `Comment`, `Tag`, `PostTag`(중간 테이블) 모델을 추가하고 관계를 설정합니다. 쿼리는 `include`/`connect`/`disconnect`로 관리하면 됩니다.

**Q5. 배포 시 연결 수 제한은?**
A. Postgres는 연결이 비싼 자원입니다. **커넥션 풀러**(pgbouncer) 또는 Prisma의 Accelerate/데이터프록시 사용을 고려하세요.

