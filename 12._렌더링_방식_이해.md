# Next.js 12장 - 렌더링 방식 이해

## 목차
1. [렌더링 방식 개념](#1-렌더링-방식-개념)
2. [CSR (Client-Side Rendering)](#2-csr-client-side-rendering)
3. [SSR (Server-Side Rendering)](#3-ssr-server-side-rendering)
4. [SSG (Static Site Generation)](#4-ssg-static-site-generation)
5. [ISR (Incremental Static Regeneration)](#5-isr-incremental-static-regeneration)
6. [App Router에서의 데이터 패칭](#6-app-router에서의-데이터-패칭)
7. [실습 프로젝트](#7-실습-프로젝트)

---

## 1. 렌더링 방식 개념

### 1.1 웹 페이지 렌더링이란?

웹 페이지 렌더링은 서버에서 받은 데이터를 브라우저에서 사용자가 볼 수 있는 형태로 변환하는 과정입니다. Next.js는 다양한 렌더링 방식을 제공하여 각각의 장단점을 활용할 수 있습니다.

### 1.2 렌더링 방식 비교

| 방식 | 렌더링 위치 | 초기 로딩 | SEO | 사용자 경험 |
|------|-------------|----------|-----|------------|
| CSR | 클라이언트 | 느림 | 불리 | 상호작용 빠름 |
| SSR | 서버 | 빠름 | 유리 | 페이지 이동 시 느림 |
| SSG | 빌드 시 | 매우 빠름 | 매우 유리 | 정적 콘텐츠만 |
| ISR | 하이브리드 | 빠름 | 유리 | 동적 + 정적 |

---

## 2. CSR (Client-Side Rendering)

### 2.1 CSR 개념

CSR은 클라이언트(브라우저)에서 JavaScript를 사용하여 페이지를 렌더링하는 방식입니다. 서버는 빈 HTML과 JavaScript 번들을 전송하고, 브라우저에서 실제 콘텐츠를 생성합니다.

### 2.2 CSR 특징

**장점:**
- 페이지 간 이동이 빠름
- 서버 부하가 적음
- 풍부한 상호작용 가능

**단점:**
- 초기 로딩이 느림
- SEO에 불리
- JavaScript 비활성화 시 작동하지 않음

### 2.3 Next.js에서 CSR 구현

```typescript
'use client';

import { useState, useEffect } from 'react';

interface Post {
  id: number;
  title: string;
  body: string;
  userId: number;
}

export default function CSRExample() {
  const [posts, setPosts] = useState<Post[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchPosts = async () => {
      try {
        setLoading(true);
        const response = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5');
        
        if (!response.ok) {
          throw new Error('Failed to fetch posts');
        }
        
        const data: Post[] = await response.json();
        setPosts(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
      } finally {
        setLoading(false);
      }
    };

    fetchPosts();
  }, []);

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="max-w-4xl mx-auto p-6">
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
          Error: {error}
        </div>
      </div>
    );
  }

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6 text-gray-800">
        CSR Example - Client Side Rendering
      </h1>
      
      <div className="grid gap-6">
        {posts.map((post) => (
          <div key={post.id} className="bg-white border border-gray-200 rounded-lg p-6 shadow-sm">
            <h2 className="text-xl font-semibold mb-2 text-gray-800">
              {post.title}
            </h2>
            <p className="text-gray-600 leading-relaxed">{post.body}</p>
            <div className="mt-4 text-sm text-gray-500">
              User ID: {post.userId} | Post ID: {post.id}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

---

## 3. SSR (Server-Side Rendering)

### 3.1 SSR 개념

SSR은 서버에서 HTML을 완전히 렌더링하여 클라이언트에게 전송하는 방식입니다. 사용자는 즉시 콘텐츠를 볼 수 있으며, SEO에 유리합니다.

### 3.2 SSR 특징

**장점:**
- 빠른 초기 페이지 로딩
- SEO 최적화
- 저성능 디바이스에서도 잘 작동

**단점:**
- 서버 부하 증가
- 페이지 이동 시 전체 페이지 새로고침
- TTFB(Time To First Byte)가 길어질 수 있음

### 3.3 App Router에서 SSR 구현

```typescript
// app/ssr-example/page.tsx
interface Post {
  id: number;
  title: string;
  body: string;
  userId: number;
}

// 서버에서 데이터를 가져오는 함수
async function getPosts(): Promise<Post[]> {
  const response = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5', {
    // Next.js 15+에서는 기본적으로 캐시되므로, 실시간 데이터가 필요한 경우 no-store 사용
    cache: 'no-store'
  });
  
  if (!response.ok) {
    throw new Error('Failed to fetch posts');
  }
  
  return response.json();
}

export default async function SSRExample() {
  // 서버에서 데이터를 가져옴
  const posts = await getPosts();

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6 text-gray-800">
        SSR Example - Server Side Rendering
      </h1>
      
      <div className="mb-4 p-4 bg-blue-50 border border-blue-200 rounded-lg">
        <p className="text-blue-800">
          이 페이지는 서버에서 렌더링되었습니다. 페이지 소스를 확인하면 완전한 HTML 내용을 볼 수 있습니다.
        </p>
      </div>

      <div className="grid gap-6">
        {posts.map((post) => (
          <div key={post.id} className="bg-white border border-gray-200 rounded-lg p-6 shadow-sm">
            <h2 className="text-xl font-semibold mb-2 text-gray-800">
              {post.title}
            </h2>
            <p className="text-gray-600 leading-relaxed">{post.body}</p>
            <div className="mt-4 text-sm text-gray-500">
              User ID: {post.userId} | Post ID: {post.id}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

// 메타데이터 생성 (SSR에서도 가능)
export async function generateMetadata() {
  return {
    title: 'SSR Example - Next.js',
    description: 'Server-side rendering example with Next.js App Router',
  };
}
```

---

## 4. SSG (Static Site Generation)

### 4.1 SSG 개념

SSG는 빌드 시점에 HTML을 미리 생성하여 CDN에서 제공하는 방식입니다. 가장 빠른 로딩 속도를 제공하며 SEO에 최적화되어 있습니다.

### 4.2 SSG 특징

**장점:**
- 매우 빠른 로딩 속도
- SEO 최적화
- 서버 부하 없음
- CDN 캐싱 활용

**단점:**
- 빌드 시점의 데이터만 사용 가능
- 동적 콘텐츠 처리 제한
- 대량의 페이지가 있을 경우 빌드 시간 증가

### 4.3 App Router에서 SSG 구현

```typescript
// app/ssg-example/page.tsx
interface Post {
  id: number;
  title: string;
  body: string;
  userId: number;
}

// 정적 데이터 가져오기 (빌드 시점에 실행)
async function getPosts(): Promise<Post[]> {
  const response = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5');
  
  if (!response.ok) {
    throw new Error('Failed to fetch posts');
  }
  
  return response.json();
}

export default async function SSGExample() {
  const posts = await getPosts();

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6 text-gray-800">
        SSG Example - Static Site Generation
      </h1>
      
      <div className="mb-4 p-4 bg-green-50 border border-green-200 rounded-lg">
        <p className="text-green-800">
          이 페이지는 빌드 시점에 정적으로 생성되었습니다. 매우 빠른 로딩 속도를 제공합니다.
        </p>
      </div>

      <div className="grid gap-6">
        {posts.map((post) => (
          <div key={post.id} className="bg-white border border-gray-200 rounded-lg p-6 shadow-sm">
            <h2 className="text-xl font-semibold mb-2 text-gray-800">
              {post.title}
            </h2>
            <p className="text-gray-600 leading-relaxed">{post.body}</p>
            <div className="mt-4 text-sm text-gray-500">
              User ID: {post.userId} | Post ID: {post.id}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 4.4 동적 경로 SSG 구현

```typescript
// app/posts/[id]/page.tsx
interface Post {
  id: number;
  title: string;
  body: string;
  userId: number;
}

interface User {
  id: number;
  name: string;
  email: string;
}

// 동적 경로를 위한 매개변수 생성
export async function generateStaticParams() {
  const posts = await fetch('https://jsonplaceholder.typicode.com/posts')
    .then((res) => res.json());
  
  // 처음 10개 포스트만 정적 생성
  return posts.slice(0, 10).map((post: Post) => ({
    id: post.id.toString(),
  }));
}

// 포스트 데이터 가져오기
async function getPost(id: string): Promise<Post> {
  const response = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`);
  
  if (!response.ok) {
    throw new Error('Failed to fetch post');
  }
  
  return response.json();
}

// 사용자 데이터 가져오기
async function getUser(userId: number): Promise<User> {
  const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);
  
  if (!response.ok) {
    throw new Error('Failed to fetch user');
  }
  
  return response.json();
}

export default async function PostPage({ params }: { params: { id: string } }) {
  const post = await getPost(params.id);
  const user = await getUser(post.userId);

  return (
    <div className="max-w-4xl mx-auto p-6">
      <div className="mb-6">
        <h1 className="text-3xl font-bold mb-2 text-gray-800">
          {post.title}
        </h1>
        <div className="text-sm text-gray-500">
          작성자: {user.name} ({user.email}) | 포스트 ID: {post.id}
        </div>
      </div>

      <div className="bg-white border border-gray-200 rounded-lg p-6 shadow-sm">
        <p className="text-gray-700 leading-relaxed text-lg">
          {post.body}
        </p>
      </div>
    </div>
  );
}

// 메타데이터 생성
export async function generateMetadata({ params }: { params: { id: string } }) {
  const post = await getPost(params.id);
  
  return {
    title: `${post.title} - Next.js Blog`,
    description: post.body.substring(0, 160),
  };
}
```

---

## 5. ISR (Incremental Static Regeneration)

### 5.1 ISR 개념

ISR은 SSG의 장점을 유지하면서도 데이터를 주기적으로 업데이트할 수 있는 하이브리드 방식입니다. 설정한 시간 간격으로 백그라운드에서 페이지를 재생성합니다.

### 5.2 ISR 특징

**장점:**
- SSG의 성능 + 동적 데이터 업데이트
- 서버 부하 최소화
- 항상 최신 콘텐츠 제공

**단점:**
- 복잡한 캐싱 전략 필요
- 첫 번째 요청 시 약간의 지연 가능

### 5.3 App Router에서 ISR 구현

```typescript
// app/isr-example/page.tsx
interface Post {
  id: number;
  title: string;
  body: string;
  userId: number;
  timestamp?: string;
}

// ISR을 위한 데이터 가져오기 (60초마다 재생성)
async function getPosts(): Promise<Post[]> {
  const response = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5', {
    next: { revalidate: 60 } // 60초마다 재검증
  });
  
  if (!response.ok) {
    throw new Error('Failed to fetch posts');
  }
  
  const posts: Post[] = await response.json();
  
  // 현재 시간 추가 (데이터 업데이트 확인용)
  return posts.map(post => ({
    ...post,
    timestamp: new Date().toISOString()
  }));
}

export default async function ISRExample() {
  const posts = await getPosts();

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6 text-gray-800">
        ISR Example - Incremental Static Regeneration
      </h1>
      
      <div className="mb-4 p-4 bg-purple-50 border border-purple-200 rounded-lg">
        <p className="text-purple-800">
          이 페이지는 60초마다 백그라운드에서 재생성됩니다. 
          정적 페이지의 성능과 동적 콘텐츠의 신선함을 모두 제공합니다.
        </p>
        <p className="text-purple-600 text-sm mt-2">
          마지막 업데이트: {posts[0]?.timestamp ? new Date(posts[0].timestamp).toLocaleString('ko-KR') : 'N/A'}
        </p>
      </div>

      <div className="grid gap-6">
        {posts.map((post) => (
          <div key={post.id} className="bg-white border border-gray-200 rounded-lg p-6 shadow-sm">
            <h2 className="text-xl font-semibold mb-2 text-gray-800">
              {post.title}
            </h2>
            <p className="text-gray-600 leading-relaxed">{post.body}</p>
            <div className="mt-4 text-sm text-gray-500">
              User ID: {post.userId} | Post ID: {post.id}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

---

## 6. App Router에서의 데이터 패칭

### 6.1 캐싱 전략

App Router에서는 `fetch` 함수의 옵션을 통해 다양한 캐싱 전략을 설정할 수 있습니다.

```typescript
// 다양한 캐싱 전략 예제
async function fetchWithDifferentStrategies() {
  // 1. 기본 캐싱 (SSG와 유사)
  const staticData = await fetch('https://api.example.com/static');
  
  // 2. 캐시 없음 (SSR과 유사)
  const dynamicData = await fetch('https://api.example.com/dynamic', {
    cache: 'no-store'
  });
  
  // 3. 시간 기반 재검증 (ISR과 유사)
  const revalidatedData = await fetch('https://api.example.com/timed', {
    next: { revalidate: 3600 } // 1시간마다 재검증
  });
  
  // 4. 태그 기반 재검증
  const taggedData = await fetch('https://api.example.com/tagged', {
    next: { tags: ['posts'] }
  });
  
  return {
    staticData: await staticData.json(),
    dynamicData: await dynamicData.json(),
    revalidatedData: await revalidatedData.json(),
    taggedData: await taggedData.json()
  };
}
```

### 6.2 에러 처리 및 로딩 상태

```typescript
// app/data-fetching-example/page.tsx
import { Suspense } from 'react';

// 에러 바운더리 컴포넌트
function ErrorBoundary({ children }: { children: React.ReactNode }) {
  return (
    <div>
      {children}
    </div>
  );
}

// 로딩 컴포넌트
function LoadingSpinner() {
  return (
    <div className="flex justify-center items-center p-8">
      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
      <span className="ml-2 text-gray-600">데이터를 불러오는 중...</span>
    </div>
  );
}

// 데이터 컴포넌트
async function DataComponent() {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=3', {
      next: { revalidate: 30 }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const posts = await response.json();
    
    return (
      <div className="grid gap-4">
        {posts.map((post: any) => (
          <div key={post.id} className="p-4 border rounded-lg">
            <h3 className="font-semibold">{post.title}</h3>
            <p className="text-gray-600 text-sm mt-2">{post.body}</p>
          </div>
        ))}
      </div>
    );
  } catch (error) {
    return (
      <div className="p-4 bg-red-50 border border-red-200 rounded-lg">
        <p className="text-red-600">
          데이터를 불러오는 중 오류가 발생했습니다: {error instanceof Error ? error.message : '알 수 없는 오류'}
        </p>
      </div>
    );
  }
}

export default function DataFetchingExample() {
  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-2xl font-bold mb-6">데이터 패칭 예제</h1>
      
      <Suspense fallback={<LoadingSpinner />}>
        <DataComponent />
      </Suspense>
    </div>
  );
}
```

---

## 7. 실습 프로젝트

### 7.1 프로젝트 설정

새로운 Next.js 프로젝트를 생성합니다.

```bash
npx create-next-app@latest rendering-tutorial --typescript --eslint --tailwind --src-dir --app --turbo --alias
cd rendering-tutorial
```

### 7.2 프로젝트 구조

```
rendering-tutorial/
├── src/
│   └── app/
│       ├── layout.tsx
│       ├── page.tsx
│       ├── csr-example/
│       │   └── page.tsx
│       ├── ssr-example/
│       │   └── page.tsx
│       ├── ssg-example/
│       │   └── page.tsx
│       ├── isr-example/
│       │   └── page.tsx
│       └── posts/
│           └── [id]/
│               └── page.tsx
├── package.json
├── tailwind.config.js
└── tsconfig.json
```

### 7.3 루트 레이아웃 설정

```typescript
// src/app/layout.tsx
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import Link from 'next/link';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'Next.js Rendering Tutorial',
  description: 'Learn about different rendering strategies in Next.js',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ko">
      <body className={inter.className}>
        <nav className="bg-gray-800 text-white p-4">
          <div className="max-w-6xl mx-auto flex justify-between items-center">
            <Link href="/">
              <h1 className="text-xl font-bold cursor-pointer hover:text-gray-300">
                Next.js Rendering Tutorial
              </h1>
            </Link>
            <div className="space-x-4">
              <Link href="/" className="hover:text-gray-300 transition-colors">
                홈
              </Link>
              <Link href="/csr-example" className="hover:text-gray-300 transition-colors">
                CSR
              </Link>
              <Link href="/ssr-example" className="hover:text-gray-300 transition-colors">
                SSR
              </Link>
              <Link href="/ssg-example" className="hover:text-gray-300 transition-colors">
                SSG
              </Link>
              <Link href="/isr-example" className="hover:text-gray-300 transition-colors">
                ISR
              </Link>
            </div>
          </div>
        </nav>
        <main className="min-h-screen bg-gray-50">
          {children}
        </main>
      </body>
    </html>
  );
}
```

### 7.4 메인 페이지

```typescript
// src/app/page.tsx
import Link from 'next/link';

export default function Home() {
  const examples = [
    {
      title: 'CSR (Client-Side Rendering)',
      description: '클라이언트에서 데이터를 가져와 렌더링합니다.',
      href: '/csr-example',
      color: 'bg-blue-500',
    },
    {
      title: 'SSR (Server-Side Rendering)',
      description: '서버에서 데이터를 가져와 렌더링합니다.',
      href: '/ssr-example',
      color: 'bg-green-500',
    },
    {
      title: 'SSG (Static Site Generation)',
      description: '빌드 시점에 정적 페이지를 생성합니다.',
      href: '/ssg-example',
      color: 'bg-purple-500',
    },
    {
      title: 'ISR (Incremental Static Regeneration)',
      description: '정적 페이지를 주기적으로 업데이트합니다.',
      href: '/isr-example',
      color: 'bg-orange-500',
    },
  ];

  return (
    <div className="max-w-6xl mx-auto p-6">
      <div className="text-center mb-12">
        <h1 className="text-4xl font-bold text-gray-800 mb-4">
          Next.js 렌더링 방식 이해
        </h1>
        <p className="text-xl text-gray-600 max-w-3xl mx-auto">
          CSR, SSR, SSG, ISR의 차이점을 실제 예제를 통해 학습해보세요.
        </p>
      </div>

      <div className="grid md:grid-cols-2 gap-6">
        {examples.map((example) => (
          <Link
            key={example.href}
            href={example.href}
            className="group block p-6 bg-white rounded-lg shadow-md hover:shadow-lg transition-shadow"
          >
            <div className={`inline-block px-3 py-1 rounded-full text-white text-sm font-medium mb-3 ${example.color}`}>
              {example.title.split(' ')[0]}
            </div>
            <h2 className="text-xl font-semibold text-gray-800 mb-2 group-hover:text-blue-600">
              {example.title}
            </h2>
            <p className="text-gray-600">
              {example.description}
            </p>
            <div className="mt-4 text-blue-600 font-medium group-hover:text-blue-800">
              예제 보기 →
            </div>
          </Link>
        ))}
      </div>

      <div className="mt-12 p-6 bg-white rounded-lg shadow-md">
        <h2 className="text-2xl font-semibold text-gray-800 mb-4">
          각 렌더링 방식 비교
        </h2>
        <div className="overflow-x-auto">
          <table className="w-full text-left">
            <thead>
              <tr className="border-b border-gray-200">
                <th className="py-3 px-4 font-semibold text-gray-700">렌더링 방식</th>
                <th className="py-3 px-4 font-semibold text-gray-700">실행 시점</th>
                <th className="py-3 px-4 font-semibold text-gray-700">초기 로딩</th>
                <th className="py-3 px-4 font-semibold text-gray-700">SEO</th>
                <th className="py-3 px-4 font-semibold text-gray-700">사용 사례</th>
              </tr>
            </thead>
            <tbody>
              <tr className="border-b border-gray-100">
                <td className="py-3 px-4 font-medium text-blue-600">CSR</td>
                <td className="py-3 px-4 text-gray-600">클라이언트</td>
                <td className="py-3 px-4 text-gray-600">느림</td>
                <td className="py-3 px-4 text-gray-600">불리</td>
                <td className="py-3 px-4 text-gray-600">대시보드, SPA</td>
              </tr>
              <tr className="border-b border-gray-100">
                <td className="py-3 px-4 font-medium text-green-600">SSR</td>
                <td className="py-3 px-4 text-gray-600">서버</td>
                <td className="py-3 px-4 text-gray-600">빠름</td>
                <td className="py-3 px-4 text-gray-600">유리</td>
                <td className="py-3 px-4 text-gray-600">뉴스, 블로그</td>
              </tr>
              <tr className="border-b border-gray-100">
                <td className="py-3 px-4 font-medium text-purple-600">SSG</td>
                <td className="py-3 px-4 text-gray-600">빌드 시점</td>
                <td className="py-3 px-4 text-gray-600">매우 빠름</td>
                <td className="py-3 px-4 text-gray-600">매우 유리</td>
                <td className="py-3 px-4 text-gray-600">문서, 랜딩 페이지</td>
              </tr>
              <tr>
                <td className="py-3 px-4 font-medium text-orange-600">ISR</td>
                <td className="py-3 px-4 text-gray-600">하이브리드</td>
                <td className="py-3 px-4 text-gray-600">빠름</td>
                <td className="py-3 px-4 text-gray-600">유리</td>
                <td className="py-3 px-4 text-gray-600">전자상거래, CMS</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
}
```

### 7.5 공통 타입 정의

```typescript
// src/types/index.ts
export interface Post {
  id: number;
  title: string;
  body: string;
  userId: number;
}

export interface User {
  id: number;
  name: string;
  username: string;
  email: string;
  address: {
    street: string;
    suite: string;
    city: string;
    zipcode: string;
    geo: {
      lat: string;
      lng: string;
    };
  };
  phone: string;
  website: string;
  company: {
    name: string;
    catchPhrase: string;
    bs: string;
  };
}

export interface Comment {
  postId: number;
  id: number;
  name: string;
  email: string;
  body: string;
}
```

### 7.6 CSR 예제 페이지

```typescript
// src/app/csr-example/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { Post } from '@/types';

export default function CSRExample() {
  const [posts, setPosts] = useState<Post[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchPosts = async () => {
      try {
        setLoading(true);
        // 의도적으로 지연 시간 추가 (CSR의 특성을 보여주기 위해)
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const response = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5');
        
        if (!response.ok) {
          throw new Error('Failed to fetch posts');
        }
        
        const data: Post[] = await response.json();
        setPosts(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
      } finally {
        setLoading(false);
      }
    };

    fetchPosts();
  }, []);

  if (loading) {
    return (
      <div className="max-w-4xl mx-auto p-6">
        <h1 className="text-3xl font-bold mb-6 text-gray-800">
          CSR Example - Client Side Rendering
        </h1>
        <div className="flex justify-center items-center min-h-64">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <p className="text-gray-600">클라이언트에서 데이터를 로딩 중...</p>
          </div>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="max-w-4xl mx-auto p-6">
        <h1 className="text-3xl font-bold mb-6 text-gray-800">
          CSR Example - Client Side Rendering
        </h1>
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
          Error: {error}
        </div>
      </div>
    );
  }

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6 text-gray-800">
        CSR Example - Client Side Rendering
      </h1>
      
      <div className="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
        <h2 className="font-semibold text-blue-800 mb-2">CSR 특징:</h2>
        <ul className="text-blue-700 text-sm space-y-1">
          <li>• 페이지 소스 보기를 하면 빈 HTML을 확인할 수 있습니다</li>
          <li>• JavaScript가 실행된 후에 콘텐츠가 나타납니다</li>
          <li>• 초기 로딩 시 스피너가 표시됩니다</li>
          <li>• SEO에는 불리하지만 상호작용이 빠릅니다</li>
        </ul>
      </div>

      <div className="grid gap-6">
        {posts.map((post) => (
          <div key={post.id} className="bg-white border border-gray-200 rounded-lg p-6 shadow-sm hover:shadow-md transition-shadow">
            <h2 className="text-xl font-semibold mb-2 text-gray-800">
              {post.title}
            </h2>
            <p className="text-gray-600 leading-relaxed">{post.body}</p>
            <div className="mt-4 flex justify-between items-center">
              <div className="text-sm text-gray-500">
                User ID: {post.userId} | Post ID: {post.id}
              </div>
              <button className="text-blue-600 hover:text-blue-800 text-sm font-medium">
                자세히 보기
              </button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 7.7 고급 실습: 하이브리드 렌더링

```typescript
// src/app/hybrid-example/page.tsx
import { Suspense } from 'react';
import { Post } from '@/types';

// 정적 데이터 (SSG)
async function getStaticPosts(): Promise<Post[]> {
  const response = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=3');
  return response.json();
}

// 동적 데이터 (SSR)
async function getDynamicPosts(): Promise<Post[]> {
  const response = await fetch('https://jsonplaceholder.typicode.com/posts?_start=3&_limit=3', {
    cache: 'no-store'
  });
  return response.json();
}

// 클라이언트 컴포넌트 (CSR)
function ClientComponent() {
  return (
    <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg">
      <h3 className="font-semibold text-blue-800 mb-2">클라이언트 컴포넌트</h3>
      <p className="text-blue-700 text-sm">
        이 부분은 클라이언트에서 렌더링되며, 상태 관리와 이벤트 처리가 가능합니다.
      </p>
      <button 
        onClick={() => alert('클라이언트에서 실행됩니다!')}
        className="mt-2 px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700"
      >
        클릭해보세요
      </button>
    </div>
  );
}

// 로딩 컴포넌트
function PostsLoading() {
  return (
    <div className="space-y-4">
      {[1, 2, 3].map((i) => (
        <div key={i} className="animate-pulse">
          <div className="bg-gray-200 h-6 rounded mb-2"></div>
          <div className="bg-gray-200 h-20 rounded"></div>
        </div>
      ))}
    </div>
  );
}

// 동적 포스트 컴포넌트
async function DynamicPosts() {
  const posts = await getDynamicPosts();
  
  return (
    <div>
      <h3 className="font-semibold text-gray-800 mb-4">동적 콘텐츠 (SSR)</h3>
      <div className="space-y-4">
        {posts.map((post) => (
          <div key={post.id} className="p-4 border border-gray-200 rounded-lg">
            <h4 className="font-medium text-gray-800">{post.title}</h4>
            <p className="text-gray-600 text-sm mt-2">{post.body}</p>
            <span className="text-xs text-gray-500">
              렌더링 시간: {new Date().toLocaleTimeString('ko-KR')}
            </span>
          </div>
        ))}
      </div>
    </div>
  );
}

export default async function HybridExample() {
  const staticPosts = await getStaticPosts();

  return (
    <div className="max-w-6xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6 text-gray-800">
        하이브리드 렌더링 예제
      </h1>
      
      <div className="mb-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
        <p className="text-yellow-800">
          이 페이지는 SSG, SSR, CSR을 모두 조합하여 사용합니다. 각 섹션의 렌더링 방식을 확인해보세요.
        </p>
      </div>

      <div className="grid lg:grid-cols-2 gap-8">
        {/* 정적 콘텐츠 (SSG) */}
        <div>
          <h2 className="text-xl font-semibold text-gray-800 mb-4">
            정적 콘텐츠 (SSG)
          </h2>
          <div className="space-y-4">
            {staticPosts.map((post) => (
              <div key={post.id} className="p-4 bg-green-50 border border-green-200 rounded-lg">
                <h3 className="font-medium text-gray-800">{post.title}</h3>
                <p className="text-gray-600 text-sm mt-2">{post.body}</p>
                <span className="text-xs text-green-600">빌드 시점에 생성됨</span>
              </div>
            ))}
          </div>
        </div>

        {/* 동적 콘텐츠 (SSR) */}
        <div>
          <Suspense fallback={<PostsLoading />}>
            <DynamicPosts />
          </Suspense>
        </div>
      </div>

      {/* 클라이언트 컴포넌트 (CSR) */}
      <div className="mt-8">
        <h2 className="text-xl font-semibold text-gray-800 mb-4">
          클라이언트 상호작용 (CSR)
        </h2>
        <ClientComponent />
      </div>
    </div>
  );
}
```

### 7.8 성능 최적화 예제

```typescript
// src/app/performance-example/page.tsx
import { Suspense } from 'react';
import Image from 'next/image';
import { Post } from '@/types';

// 이미지 최적화를 위한 컴포넌트
function OptimizedImage({ src, alt, width = 300, height = 200 }: {
  src: string;
  alt: string;
  width?: number;
  height?: number;
}) {
  return (
    <Image
      src={src}
      alt={alt}
      width={width}
      height={height}
      className="rounded-lg"
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAIAAoDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAhEAACAQMDBQAAAAAAAAAAAAABAgMABAUGIWGRkqGx0f/EABUBAQEAAAAAAAAAAAAAAAAAAAMF/8QAGhEAAgIDAAAAAAAAAAAAAAAAAAECEgMRkf/aAAwDAQACEQMRAD8AltJagyeH0AthI5xdrLcNM91BF5pX2HaH9bcfaSXWGaRmknyJckliyjqTzSlT54b6bk+h0R//2Q=="
      priority={false}
    />
  );
}

// 지연 로딩되는 무거운 컴포넌트
async function HeavyComponent() {
  // 의도적인 지연 (무거운 계산 시뮬레이션)
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  const posts = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=2', {
    next: { revalidate: 60 }
  }).then(res => res.json());

  return (
    <div className="space-y-4">
      <h3 className="font-semibold text-gray-800">무거운 컴포넌트 (지연 로딩)</h3>
      {posts.map((post: Post) => (
        <div key={post.id} className="p-4 border border-gray-200 rounded-lg">
          <h4 className="font-medium">{post.title}</h4>
          <p className="text-gray-600 text-sm mt-2">{post.body}</p>
        </div>
      ))}
    </div>
  );
}

// 스켈레톤 로딩 컴포넌트
function SkeletonLoader() {
  return (
    <div className="space-y-4 animate-pulse">
      <div className="h-6 bg-gray-200 rounded"></div>
      {[1, 2].map((i) => (
        <div key={i} className="space-y-2">
          <div className="h-4 bg-gray-200 rounded"></div>
          <div className="h-16 bg-gray-200 rounded"></div>
        </div>
      ))}
    </div>
  );
}

export default function PerformanceExample() {
  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6 text-gray-800">
        성능 최적화 예제
      </h1>

      <div className="grid md:grid-cols-2 gap-8">
        {/* 이미지 최적화 */}
        <div>
          <h2 className="text-xl font-semibold mb-4">이미지 최적화</h2>
          <div className="space-y-4">
            <OptimizedImage
              src="https://picsum.photos/300/200?random=1"
              alt="최적화된 이미지 1"
            />
            <p className="text-sm text-gray-600">
              Next.js Image 컴포넌트를 사용하여 자동 최적화, 지연 로딩, WebP 변환 등을 적용했습니다.
            </p>
          </div>
        </div>

        {/* 지연 로딩 */}
        <div>
          <h2 className="text-xl font-semibold mb-4">컴포넌트 지연 로딩</h2>
          <Suspense fallback={<SkeletonLoader />}>
            <HeavyComponent />
          </Suspense>
        </div>
      </div>

      {/* 성능 팁 */}
      <div className="mt-8 p-6 bg-gray-50 rounded-lg">
        <h2 className="text-xl font-semibold mb-4">성능 최적화 팁</h2>
        <div className="grid md:grid-cols-2 gap-6">
          <div>
            <h3 className="font-semibold text-green-600 mb-2">권장사항</h3>
            <ul className="text-sm text-gray-700 space-y-1">
              <li>• Next.js Image 컴포넌트 사용</li>
              <li>• Suspense와 함께 지연 로딩 활용</li>
              <li>• 적절한 캐싱 전략 선택</li>
              <li>• 코드 분할(Code Splitting) 적용</li>
              <li>• 불필요한 리렌더링 방지</li>
            </ul>
          </div>
          <div>
            <h3 className="font-semibold text-red-600 mb-2">피해야 할 것</h3>
            <ul className="text-sm text-gray-700 space-y-1">
              <li>• 모든 페이지를 SSR로 구현</li>
              <li>• 과도한 클라이언트 상태 관리</li>
              <li>• 큰 번들 크기</li>
              <li>• 불필요한 useEffect 사용</li>
              <li>• 이미지 최적화 무시</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  );
}
```

### 7.9 개발 도구 및 디버깅

```typescript
// src/app/debug-example/page.tsx
'use client';

import { useState, useEffect } from 'react';

export default function DebugExample() {
  const [renderInfo, setRenderInfo] = useState({
    renderTime: '',
    userAgent: '',
    isClient: false,
  });

  useEffect(() => {
    setRenderInfo({
      renderTime: new Date().toISOString(),
      userAgent: navigator.userAgent,
      isClient: true,
    });
  }, []);

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6 text-gray-800">
        개발 도구 및 디버깅
      </h1>

      {/* 렌더링 정보 */}
      <div className="mb-8 p-4 bg-gray-50 border border-gray-200 rounded-lg">
        <h2 className="text-lg font-semibold mb-4">렌더링 정보</h2>
        <div className="space-y-2 text-sm">
          <div>
            <strong>렌더링 시간:</strong> {renderInfo.renderTime}
          </div>
          <div>
            <strong>클라이언트 렌더링:</strong> {renderInfo.isClient ? '예' : '아니오'}
          </div>
          <div>
            <strong>User Agent:</strong> 
            <div className="mt-1 p-2 bg-white border rounded text-xs break-all">
              {renderInfo.userAgent || '서버에서는 사용할 수 없음'}
            </div>
          </div>
        </div>
      </div>

      {/* Next.js 개발 도구 */}
      <div className="mb-8">
        <h2 className="text-lg font-semibold mb-4">Next.js 개발 도구</h2>
        <div className="grid md:grid-cols-2 gap-6">
          <div className="p-4 border border-gray-200 rounded-lg">
            <h3 className="font-semibold text-blue-600 mb-2">개발 모드 명령어</h3>
            <pre className="text-xs bg-gray-100 p-2 rounded overflow-x-auto">
{`# 개발 서버 시작
npm run dev

# 빌드 및 분석
npm run build
npm run start

# 번들 분석
npx @next/bundle-analyzer`}
            </pre>
          </div>
          <div className="p-4 border border-gray-200 rounded-lg">
            <h3 className="font-semibold text-green-600 mb-2">유용한 환경변수</h3>
            <pre className="text-xs bg-gray-100 p-2 rounded overflow-x-auto">
{`# .env.local
NEXT_PUBLIC_API_URL=http://localhost:3001
NODE_ENV=development

# 분석 모드
ANALYZE=true npm run build`}
            </pre>
          </div>
        </div>
      </div>

      {/* 성능 측정 */}
      <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg">
        <h2 className="text-lg font-semibold text-blue-800 mb-4">성능 측정 도구</h2>
        <ul className="text-sm text-blue-700 space-y-2">
          <li>• <strong>React Developer Tools:</strong> 컴포넌트 트리와 프로파일링</li>
          <li>• <strong>Chrome DevTools:</strong> 네트워크, 성능, Lighthouse</li>
          <li>• <strong>Next.js Speed Insights:</strong> 실제 사용자 성능 데이터</li>
          <li>• <strong>Vercel Analytics:</strong> 웹 바이탈 모니터링</li>
        </ul>
      </div>
    </div>
  );
}
```

### 7.10 프로젝트 실행 및 테스트

```bash
# 프로젝트 실행
npm run dev

# 빌드 테스트
npm run build
npm run start

# 타입 체크
npx tsc --noEmit

# ESLint 실행
npm run lint
```

### 7.11 마무리 및 정리

이 교재를 통해 Next.js의 주요 렌더링 방식들을 실제 코드와 함께 학습했습니다. 각 방식의 특징과 적절한 사용 사례를 이해하고, 실제 프로젝트에서 적용해 보세요.

**핵심 포인트:**
- CSR: 상호작용이 많은 대시보드나 SPA
- SSR: SEO가 중요한 블로그나 뉴스 사이트
- SSG: 정적 콘텐츠가 많은 문서나 랜딩 페이지
- ISR: 콘텐츠가 주기적으로 업데이트되는 전자상거래 사이트

**다음 단계:**
- 실제 API와 연동해보기
- 에러 처리 및 로딩 상태 개선
- 성능 최적화 기법 적용
- 배포 및 모니터링 설정