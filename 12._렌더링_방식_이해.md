# 12. 렌더링 방식 이해 (CSR · SSR · SSG)

## 1) CSR vs SSR vs SSG — 무엇이 다를까?

| 방식                              | 언제 렌더링?                                         | 어디서 렌더링?  | 장점                  | 유의점                                                             |
| ------------------------------- | ----------------------------------------------- | --------- | ------------------- | --------------------------------------------------------------- |
| **CSR**(Client-Side Rendering)  | 요청 직후 빈 껍데기 HTML + JS 로드 후 **클라이언트**가 데이터 패칭/렌더 | **브라우저**  | 상호작용 풍부, CDN 캐시 쉬움  | 초기 페인트까지 시간이 더 필요(SEO는 메타/프리렌더 보강) ([Next.js][2])               |
| **SSR**(Server-Side Rendering)  | **매 요청마다** 서버가 페이지를 그려 HTML 전송                  | **서버**    | 최신 데이터, SEO 유리      | 서버 부하·응답 시간 증가, 페이지 캐싱 전략 필요 ([Next.js][3])                     |
| **SSG**(Static Site Generation) | **빌드 타임**에 HTML 미리 생성                           | **빌드 서버** | 매우 빠른 응답, CDN 캐시 최적 | 데이터가 자주 바뀌면 부적합 → \*\*ISR(revalidate)\*\*로 보완 가능 ([Next.js][4]) |

* Next.js는 페이지별로 위 방식을 \*\*혼합(Hybrid)\*\*해 쓰도록 설계되어 있습니다. ([Next.js][2])

---

## 2) Pages Router의 데이터 패칭 API 한눈에

### `getStaticProps` (SSG)

* **빌드 타임**에 실행되어 페이지에 **정적 props**를 주입합니다.
* 자주 변하지 않는 콘텐츠(문서/블로그/마케팅 페이지)에 적합.
* `revalidate`로 **ISR(Incremental Static Regeneration)** 적용 가능. ([Next.js][4])

```tsx
// pages/articles/[slug].tsx
import type { GetStaticProps, GetStaticPaths } from 'next';

export const getStaticPaths: GetStaticPaths = async () => {
  // 사전 생성할 경로
  return { paths: [{ params: { slug: 'hello' } }], fallback: 'blocking' };
};

export const getStaticProps: GetStaticProps = async (ctx) => {
  const slug = ctx.params?.slug as string;
  const res = await fetch(`https://example.com/articles/${slug}`);
  if (res.status === 404) return { notFound: true };
  const article = await res.json();
  return {
    props: { article },
    revalidate: 60, // 60초마다 백그라운드 재생성(ISR)
  };
};
```

### `getServerSideProps` (SSR)

* **매 요청마다 서버에서 실행**되어 **항상 최신 데이터**를 전달합니다.
* 페이지 안에서 별도의 API 라우트를 호출할 필요 없이, **서버에서 외부 API/DB**에 직접 접근 가능. (클라이언트 번들로 비밀이 새지 않음) ([Next.js][3])

```tsx
// pages/dashboard.tsx
import type { GetServerSideProps, InferGetServerSidePropsType } from 'next';

export const getServerSideProps: GetServerSideProps = async () => {
  const r = await fetch('https://api.example.com/metrics', { headers: { Authorization: `Bearer ${process.env.API_TOKEN}` } });
  if (!r.ok) return { notFound: true };
  return { props: { metrics: await r.json() } };
};

export default function Dashboard({ metrics }: InferGetServerSidePropsType<typeof getServerSideProps>) {
  return <pre>{JSON.stringify(metrics, null, 2)}</pre>;
}
```

> 정리: **변하지 않는 콘텐츠 → `getStaticProps`(+`revalidate`)**, **요청마다 최신 데이터/권한 확인 → `getServerSideProps`**. 공식 가이드를 페이지별로 적용하세요. ([Next.js][4])

---

## 3) 실습: 서버사이드 데이터 패칭(SSR)로 “유저 목록 + 상세” 만들기

### 3-1) 프로젝트 생성 (TypeScript + Pages Router)

```bash
npx create-next-app@latest next-rendering-ts --ts --no-app
cd next-rendering-ts
npm run dev
```

* `--ts`: 타입스크립트 템플릿, `--no-app`: **Pages Router** 사용. ([Next.js][1])

### 3-2) 폴더 구조

```
next-rendering-ts/
├─ pages/
│  ├─ index.tsx         # 홈
│  ├─ users/
│  │  ├─ index.tsx      # SSR 목록
│  │  └─ [id].tsx       # SSR 상세
├─ types/
│  └─ user.ts
└─ styles/...
```

### 3-3) 타입 정의

**`types/user.ts`**

```ts
export type User = {
  id: number;
  name: string;
  username: string;
  email: string;
};
```

### 3-4) SSR: 유저 목록

**`pages/users/index.tsx`**

```tsx
import Link from 'next/link';
import type { GetServerSideProps, InferGetServerSidePropsType } from 'next';
import type { User } from '../../types/user';

type Props = { users: User[] };

export const getServerSideProps: GetServerSideProps<Props> = async () => {
  // 서버에서 직접 외부 API 호출(클라이언트 번들에 포함되지 않음)
  const res = await fetch('https://jsonplaceholder.typicode.com/users');
  if (!res.ok) return { notFound: true };
  const users: User[] = await res.json();
  return { props: { users } }; // 매 요청마다 최신 데이터
};

export default function UsersIndex({ users }: InferGetServerSidePropsType<typeof getServerSideProps>) {
  return (
    <main style={{ padding: 24 }}>
      <h1>Users (SSR)</h1>
      <ul style={{ listStyle: 'none', padding: 0, display: 'grid', gap: 8 }}>
        {users.map(u => (
          <li key={u.id} style={{ border: '1px solid #eee', borderRadius: 12, padding: 12 }}>
            <strong>{u.name}</strong> <span style={{ color: '#6b7280' }}>@{u.username}</span>
            <div><Link href={`/users/${u.id}`}>자세히 →</Link></div>
          </li>
        ))}
      </ul>
    </main>
  );
}
```

### 3-5) SSR: 유저 상세 (동적 라우트)

**`pages/users/[id].tsx`**

```tsx
import Link from 'next/link';
import type { GetServerSideProps, InferGetServerSidePropsType } from 'next';
import type { User } from '../../types/user';

type Props = { user: User };

export const getServerSideProps: GetServerSideProps<Props> = async (ctx) => {
  const id = ctx.params?.id as string;
  const res = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`);
  if (res.status === 404) return { notFound: true };
  if (!res.ok) throw new Error(`Failed: ${res.status}`);
  const user: User = await res.json();
  return { props: { user } };
};

export default function UserDetail({ user }: InferGetServerSidePropsType<typeof getServerSideProps>) {
  return (
    <main style={{ padding: 24, display: 'grid', gap: 8 }}>
      <Link href="/users">← 목록</Link>
      <h1>{user.name}</h1>
      <p><b>username:</b> {user.username}</p>
      <p><b>email:</b> {user.email}</p>
    </main>
  );
}
```

### 3-6) (보너스) SSG로 전환해 보기

* 목록은 여전히 SSR, **상세만 SSG**로 바꾸려면 `getStaticPaths` + `getStaticProps` 사용:

```tsx
// pages/users/[id].tsx (대체 버전: SSG + ISR)
import type { GetStaticPaths, GetStaticProps, InferGetStaticPropsType } from 'next';
import type { User } from '../../types/user';

export const getStaticPaths: GetStaticPaths = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/users');
  const users: User[] = await res.json();
  return {
    paths: users.map(u => ({ params: { id: String(u.id) } })),
    fallback: 'blocking'
  };
};

export const getStaticProps: GetStaticProps<{ user: User }> = async (ctx) => {
  const id = ctx.params?.id as string;
  const res = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`);
  if (res.status === 404) return { notFound: true };
  const user: User = await res.json();
  return { props: { user }, revalidate: 60 }; // 60초마다 백그라운드 재생성
};

export default function UserDetail({ user }: InferGetStaticPropsType<typeof getStaticProps>) {
  return <pre style={{ padding: 24 }}>{JSON.stringify(user, null, 2)}</pre>;
}
```

> 공식 문서: **CSR/SSR/SSG 개념**, **`getStaticProps`/`getServerSideProps` 사용법**은 여기에서 상세히 확인할 수 있습니다. ([Next.js][2])

---

## 4) 실습 미션 (Hands-on)

1. **검색 쿼리 반영**

   * `/users?q=Leanne`처럼 쿼리스트링을 받아, SSR에서 서버 측 필터링 후 결과만 내려보세요(서버에서 필터링 → 클라이언트 전달).

2. **오류/빈 상태 처리**

   * API 오류 시 `notFound: true` 혹은 에러 던지기(`throw new Error`)로 테스트. 에러 페이지를 `pages/_error.tsx`로 커스터마이즈.

3. **하이브리드 적용**

   * 목록은 SSR, 상세는 **SSG+ISR**로 운영해 보고, 목록에서 상세로 이동 시 **속도/신선도 차이**를 팀과 토론하세요.

4. **보안 값 사용**

   * `.env.local`에 `API_TOKEN`을 넣고, SSR 내부에서만 헤더로 전달해보세요(클라이언트로 노출 금지).

5. **응답 헤더 캐싱**

   * SSR에서 `context.res.setHeader('Cache-Control', 's-maxage=60, stale-while-revalidate=600')` 설정 후 CDN/프록시 캐시 전략을 관찰.

---

## 5) 자주 하는 실수 & 베스트 프랙티스

* **Next를 Vite로 시작하려 함** → Next는 `create-next-app`을 사용하세요. 플래그로 TS/Pages Router 선택 가능. ([Next.js][1])
* **서버 비밀 노출** → 비밀 키/토큰은 \*\*반드시 서버 측(`getServerSideProps`)\*\*에서만 사용하세요. ([Next.js][3])
* **데이터 신선도 과설계** → 바뀜 빈도에 맞춰 **SSG(+ISR) vs SSR**을 고르세요. (문서성=SSG, 대시보드/권한=SSR) ([Next.js][4])
* **불필요한 API Route 경유** → SSR에선 **외부 API/DB를 바로 호출**하면 됩니다(서버에서 실행). ([Next.js][3])

---

## 6) 예상 질문(Q\&A)

**Q1. `getInitialProps`는 이제 안 쓰나요?**
A. 레거시입니다. Pages Router에서는 `getStaticProps`/`getServerSideProps` 사용이 권장됩니다. ([LogRocket Blog][5])

**Q2. App Router와의 관계는?**
A. App Router에선 서버 컴포넌트·캐싱 규칙으로 **다른 패턴**을 사용합니다. 본 장은 **Pages Router 학습**에 집중했습니다. (혼용 가능) ([Next.js][2])

**Q3. SEO는 SSR이 무조건 더 좋은가요?**
A. “항상”은 아닙니다. 정적 콘텐츠는 \*\*SSG(+ISR)\*\*가 더 빠르고 안정적으로 좋은 결과를 내는 경우가 많습니다. 변경/권한 의존 페이지는 SSR이 적합합니다. ([Next.js][4])

**Q4. `revalidate` 값은 어떻게 정하나요?**
A. 데이터의 **변경 주기**와 **허용 가능한 오래됨**(staleness)을 기준으로 실험적으로 결정합니다. 초단위입니다. ([Next.js][4])

---

[1]: https://nextjs.org/docs/13/pages/api-reference/create-next-app?utm_source=chatgpt.com "API Reference: create-next-app | Next.js"
[2]: https://nextjs.org/docs/pages/building-your-application/rendering/client-side-rendering?utm_source=chatgpt.com "Client-side Rendering (CSR) - Next.js"
[3]: https://nextjs.org/docs/pages/building-your-application/data-fetching/get-server-side-props?utm_source=chatgpt.com "Data Fetching: getServerSideProps | Next.js"
[4]: https://nextjs.org/docs/pages/building-your-application/data-fetching/get-static-props?utm_source=chatgpt.com "Data Fetching: getStaticProps | Next.js"
[5]: https://blog.logrocket.com/data-fetching-next-js-getserversideprops-getstaticprops/?utm_source=chatgpt.com "Data fetching in Next.js with - LogRocket Blog"
