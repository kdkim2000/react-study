# 05. 리액트 훅 기초

## 1) `useEffect`로 생명주기 이해하기

### `useEffect`는 언제 실행되나?

* **렌더 → DOM 업데이트 후** 비동기적으로 실행됩니다.
* 의존성 배열에 따라 실행 시점이 달라집니다.

  * `useEffect(fn)` : 매 렌더마다 실행 (거의 사용 안 함)
  * `useEffect(fn, [])` : **마운트 시 1회**, 그리고 **언마운트 시 정리(cleanup)**
  * `useEffect(fn, [a, b])` : `a` 또는 `b`가 바뀔 때마다

### 정리(cleanup) 함수

* `useEffect`의 반환값으로 **정리 함수**를 리턴하면,

  * 컴포넌트 **언마운트 시 1번**
  * 또는 **의존성 변경으로 다음 effect 실행 직전** 호출됩니다.
* 예: 이벤트 리스너 해제, 타이머 정리, fetch abort 등

### 흔한 패턴

```tsx
useEffect(() => {
  // 구독 시작, 타이머 시작 등
  return () => {
    // 구독 해제, 타이머 정리 등
  };
}, [deps]);
```

---

## 2) 조건부 렌더링 & 리스트 렌더링

### 조건부 렌더링

* 삼항: `{isLoading ? <Spinner/> : <Content/>}`
* AND: `{error && <ErrorView/>}`
* 상태 분기(권장): `'idle' | 'loading' | 'success' | 'error'` 로 **명시적 상태 머신**처럼 표현

### 리스트 렌더링

* `array.map()`으로 렌더링, **항상 안정적인 `key` 사용** (`id` 권장, `index` 지양)
* 요소가 복잡해지면 **프레젠테이셔널 컴포넌트로 분리** (`UserCard` 등)

---

## 3) 실습: API 호출 후 데이터 렌더링

### 3-1) 프로젝트 초기화 (Vite)

```bash
npm create vite@latest react-hooks-ts -- --template react-swc-ts
cd react-hooks-ts
npm install
npm run dev
```

### 3-2) 타입 & API 모듈

```
src/
├─ lib/
│  └─ api.ts
├─ components/
│  ├─ UserCard.tsx
│  └─ UsersList.tsx
├─ pages/
│  └─ UsersPage.tsx
├─ App.tsx
└─ main.tsx
```

**`src/lib/api.ts`**

```ts
// 간단한 Fetch 래퍼 + 타입
export type User = {
  id: number;
  name: string;
  email: string;
  username: string;
};

export async function fetchUsers(signal?: AbortSignal): Promise<User[]> {
  const res = await fetch('https://jsonplaceholder.typicode.com/users', { signal });
  if (!res.ok) throw new Error(`Failed to load: ${res.status}`);
  return (await res.json()) as User[];
}
```

### 3-3) 프레젠테이셔널 컴포넌트

**`src/components/UserCard.tsx`**

```tsx
import type { User } from '../lib/api';

type Props = { user: User };

export default function UserCard({ user }: Props) {
  return (
    <li
      style={{
        border: '1px solid #eee',
        borderRadius: 12,
        padding: 12,
        display: 'grid',
        gap: 4,
      }}
    >
      <strong>{user.name}</strong>
      <span>@{user.username}</span>
      <a href={`mailto:${user.email}`}>{user.email}</a>
    </li>
  );
}
```

**`src/components/UsersList.tsx`**

```tsx
import type { User } from '../lib/api';
import UserCard from './UserCard';

type Props = { users: User[] };

export default function UsersList({ users }: Props) {
  if (users.length === 0) {
    return <p style={{ color: '#777' }}>결과가 없습니다.</p>;
  }
  return (
    <ul style={{ listStyle: 'none', padding: 0, display: 'grid', gap: 12 }}>
      {users.map(u => <UserCard key={u.id} user={u} />)}
    </ul>
  );
}
```

### 3-4) `useEffect` + AbortController + 상태 분기

**`src/pages/UsersPage.tsx`**

```tsx
import { useEffect, useMemo, useState } from 'react';
import { fetchUsers, type User } from '../lib/api';
import UsersList from '../components/UsersList';

type Status = 'idle' | 'loading' | 'success' | 'error';

export default function UsersPage() {
  const [status, setStatus] = useState<Status>('idle');
  const [users, setUsers] = useState<User[]>([]);
  const [query, setQuery] = useState(''); // 검색어 (선택)

  useEffect(() => {
    let cancelled = false;
    const controller = new AbortController();

    async function load() {
      try {
        setStatus('loading');
        const data = await fetchUsers(controller.signal);
        if (cancelled) return; // 경쟁 상태 방지
        setUsers(data);
        setStatus('success');
      } catch (err) {
        if ((err as any)?.name === 'AbortError') return; // 취소는 무시
        console.error(err);
        setStatus('error');
      }
    }

    load();
    return () => {
      cancelled = true;
      controller.abort();
    };
  }, []); // 마운트 시 1회

  const filtered = useMemo(() => {
    const q = query.trim().toLowerCase();
    if (!q) return users;
    return users.filter(
      u =>
        u.name.toLowerCase().includes(q) ||
        u.username.toLowerCase().includes(q) ||
        u.email.toLowerCase().includes(q)
    );
  }, [users, query]);

  return (
    <section style={{ maxWidth: 720, margin: '0 auto', padding: 24, display: 'grid', gap: 16 }}>
      <h1>사용자 목록</h1>

      <label style={{ display: 'flex', gap: 8 }}>
        <input
          value={query}
          onChange={e => setQuery(e.target.value)}
          placeholder="이름/아이디/이메일 검색"
          style={{ flex: 1 }}
        />
        <button type="button" onClick={() => setQuery('')}>초기화</button>
      </label>

      {status === 'idle' && <p>대기 중…</p>}
      {status === 'loading' && <p>불러오는 중…</p>}
      {status === 'error' && (
        <div role="alert" style={{ color: 'crimson' }}>
          데이터를 불러오지 못했습니다. 잠시 후 다시 시도하세요.
        </div>
      )}
      {status === 'success' && <UsersList users={filtered} />}
    </section>
  );
}
```

### 3-5) 데모: 타이머/리스너 정리(Cleanup)

**`src/components/ResizeWatcher.tsx`**

```tsx
import { useEffect, useState } from 'react';

export default function ResizeWatcher() {
  const [w, setW] = useState(window.innerWidth);

  useEffect(() => {
    const onResize = () => setW(window.innerWidth);
    window.addEventListener('resize', onResize);
    return () => window.removeEventListener('resize', onResize); // cleanup
  }, []);

  return <small style={{ color: '#666' }}>윈도우 너비: {w}px</small>;
}
```

### 3-6) 진입점

**`src/App.tsx`**

```tsx
import UsersPage from './pages/UsersPage';
import ResizeWatcher from './components/ResizeWatcher';

export default function App() {
  return (
    <main style={{ fontFamily: 'system-ui', lineHeight: 1.5 }}>
      <UsersPage />
      <div style={{ marginTop: 16 }}>
        <ResizeWatcher />
      </div>
    </main>
  );
}
```

**`src/main.tsx`**

```tsx
import { createRoot } from 'react-dom/client';
import App from './App';
import './index.css';

createRoot(document.getElementById('root')!).render(<App />);
```

> 여기까지 실행하면 **마운트 시 1회 fetch → 로딩/오류/성공 상태 분기 → 리스트 렌더링** 흐름과
> \*\*이벤트 리스너 정리(cleanup)\*\*를 모두 체험할 수 있습니다.

---

## 4) 실습 미션 (Hands-on)

1. **리트라이 버튼**

   * `status === 'error'`일 때 “다시 시도” 버튼을 노출해 재요청 구현(요청 함수 분리).

2. **페이지네이션(클라이언트)**

   * `page` 상태(`useState<number>`) 추가, `slice`로 5개씩 표시, 페이지 이동 구현.

3. **데이터 형식 확장**

   * `UserCard`에 회사/주소 일부를 추가로 노출. 타입에 맞게 안전하게 접근(옵셔널 체이닝).

4. **로딩 스켈레톤**

   * 로딩 시 실제 카드와 비슷한 형태의 회색 블록을 렌더(접근성 `aria-busy` 고려).

5. **타임아웃/취소 고급**

   * `fetch`가 5초 이상 걸리면 `controller.abort()`로 취소 후 에러 처리.

---

## 5) 자주 하는 실수 & 베스트 프랙티스

* **의존성 배열 누락**: `useEffect`가 참조하는 값은 **의존성 배열에 포함**. 무한 루프/오래된 값 참조를 방지합니다.
* **정리 함수 누락**: 이벤트/타이머/외부 구독은 **반드시 cleanup** 구현(메모리 누수 방지).
* **경쟁 상태(race) 방치**: 빠르게 재요청 시 이전 요청이 늦게 도착해 상태를 덮을 수 있음 → **AbortController** 또는 `cancelled` 플래그로 방지.
* **불필요한 렌더**: 무거운 필터/정렬은 `useMemo` 로 메모이즈.
* **`key`로 `index` 사용**: 가급적 지양, **안정적인 고유 id** 사용.

---

## 6) 예상 질문(Q\&A)

**Q1. 왜 `useEffect`는 렌더 후 실행되나요?**
A. DOM이 업데이트된 이후 \*\*부수효과(side-effect)\*\*를 안전하게 수행하기 위함입니다. 렌더 중에는 순수해야 합니다.

**Q2. 의존성 배열에 함수를 넣으면 참조가 매번 바뀌지 않나요?**
A. 맞습니다. 필요하다면 \*\*`useCallback`\*\*으로 안정적인 함수를 만들어 의존성 변화를 줄이세요.

**Q3. 언마운트 시 setState 경고가 뜹니다.**
A. 비동기 작업 결과가 돌아올 때 이미 언마운트되었을 수 있습니다. **AbortController**로 요청을 취소하거나 `cancelled` 플래그로 가드하세요.

**Q4. 로딩/에러/빈 결과 분기는 어디서 하나요?**
A. **컨테이너(`UsersPage`)에서 상태를 분기**하고, 리스트는 **프레젠테이셔널**하게 유지하면 테스트/재사용이 쉬워집니다.

**Q5. 서버 API가 느릴 때 UX를 어떻게 개선하죠?**
A. **스켈레톤 UI**, **낙관적 업데이트**, **에러 재시도(backoff)**, **로컬 캐시(SWR/React Query)** 등을 고려하세요. (추후 Next.js/데이터 패칭에서 심화)

