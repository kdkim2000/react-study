# Next.js 15 - 동적 라우팅과 SEO 완벽 가이드

## 목차
1. [개요](#개요)
2. [동적 라우팅 기본 개념](#동적-라우팅-기본-개념)
3. [파일 기반 라우팅 시스템](#파일-기반-라우팅-시스템)
4. [동적 경로 매개변수 활용](#동적-경로-매개변수-활용)
5. [Next.js 15의 SEO 최적화](#nextjs-15의-seo-최적화)
6. [Metadata API 활용](#metadata-api-활용)
7. [실습: 블로그 상세 페이지 구현](#실습-블로그-상세-페이지-구현)
8. [고급 SEO 테크닉](#고급-seo-테크닉)
9. [성능 최적화](#성능-최적화)
10. [마무리](#마무리)

---

## 개요

Next.js 15는 강력한 파일 기반 라우팅 시스템과 향상된 SEO 기능을 제공합니다. 이 장에서는 동적 라우팅의 핵심 개념부터 실제 블로그 상세 페이지 구현까지 단계별로 학습하겠습니다.

### 주요 학습 목표
- Next.js 15의 App Router를 활용한 동적 라우팅 구현
- 최신 Metadata API를 사용한 SEO 최적화
- TypeScript와 Material-UI를 활용한 현대적인 개발
- Turbopack을 활용한 빠른 개발 환경 구축

### 개발 환경 설정

먼저 최신 Next.js 15 프로젝트를 생성하겠습니다:

```bash
# Next.js 15 프로젝트 생성 (Turbopack 포함)
npx create-next-app@latest blog-app --typescript --tailwind --eslint --app --use-npm

cd blog-app

# Material-UI 설치
npm install @mui/material @emotion/react @emotion/styled @mui/icons-material

# 개발 서버 실행 (Turbopack 사용)
npm run dev -- --turbo
```

---

## 동적 라우팅 기본 개념

### 1. App Router vs Pages Router

Next.js 15는 App Router를 기본으로 사용하며, 이는 기존의 Pages Router보다 더 직관적이고 강력한 라우팅 시스템을 제공합니다.

#### App Router 구조
```
app/
├── page.tsx              // 홈페이지 (/)
├── about/
│   └── page.tsx          // 정적 경로 (/about)
├── blog/
│   ├── page.tsx          // 블로그 목록 (/blog)
│   └── [slug]/
│       └── page.tsx      // 동적 경로 (/blog/[slug])
└── layout.tsx            // 루트 레이아웃
```

### 2. 동적 라우팅의 장점

- **유연성**: 하나의 컴포넌트로 여러 경로 처리
- **SEO 최적화**: 각 페이지별 고유한 메타데이터 설정
- **코드 재사용**: 템플릿 기반의 페이지 구조
- **성능 향상**: 필요한 데이터만 로드

---

## 파일 기반 라우팅 시스템

### 1. 기본 동적 라우팅

#### 단일 매개변수 라우팅 `[id]`
```typescript
// app/blog/[id]/page.tsx
interface BlogPostProps {
  params: {
    id: string;
  };
}

export default function BlogPost({ params }: BlogPostProps) {
  const { id } = params;
  
  return (
    <div>
      <h1>블로그 포스트 ID: {id}</h1>
    </div>
  );
}
```

### 2. 다중 동적 세그먼트

#### 중첩된 동적 라우팅
```typescript
// app/category/[category]/post/[id]/page.tsx
interface CategoryPostProps {
  params: {
    category: string;
    id: string;
  };
}

export default function CategoryPost({ params }: CategoryPostProps) {
  const { category, id } = params;
  
  return (
    <div>
      <h1>카테고리: {category}</h1>
      <h2>포스트 ID: {id}</h2>
    </div>
  );
}
```

### 3. Catch-all 라우팅

#### 모든 경로 캐치 `[...slug]`
```typescript
// app/docs/[...slug]/page.tsx
interface DocsProps {
  params: {
    slug: string[];
  };
}

export default function Docs({ params }: DocsProps) {
  const { slug } = params;
  
  return (
    <div>
      <h1>문서 경로: {slug.join('/')}</h1>
    </div>
  );
}
```

#### 선택적 Catch-all 라우팅 `[[...slug]]`
```typescript
// app/shop/[[...category]]/page.tsx
interface ShopProps {
  params: {
    category?: string[];
  };
}

export default function Shop({ params }: ShopProps) {
  const { category = [] } = params;
  
  if (category.length === 0) {
    return <div>전체 상품</div>;
  }
  
  return (
    <div>
      <h1>카테고리: {category.join(' > ')}</h1>
    </div>
  );
}
```

---

## 동적 경로 매개변수 활용

### 1. URL 매개변수 파싱

```typescript
// app/blog/[slug]/page.tsx
import { notFound } from 'next/navigation';

interface BlogPostProps {
  params: {
    slug: string;
  };
  searchParams: {
    [key: string]: string | string[] | undefined;
  };
}

export default async function BlogPost({ 
  params, 
  searchParams 
}: BlogPostProps) {
  const { slug } = params;
  const { tab = 'content', sort = 'desc' } = searchParams;
  
  // 데이터 검증
  if (!slug || slug.length < 3) {
    notFound();
  }
  
  return (
    <div>
      <h1>블로그: {slug}</h1>
      <p>현재 탭: {tab}</p>
      <p>정렬: {sort}</p>
    </div>
  );
}
```

### 2. 데이터 패칭과 타입 안정성

```typescript
// types/blog.ts
export interface BlogPost {
  id: string;
  title: string;
  content: string;
  author: string;
  publishedAt: string;
  tags: string[];
  slug: string;
}

// lib/blog.ts
export async function getBlogPost(slug: string): Promise<BlogPost | null> {
  try {
    // API 호출 또는 데이터베이스 쿼리
    const response = await fetch(`https://api.example.com/posts/${slug}`, {
      next: { revalidate: 3600 }, // ISR: 1시간마다 재검증
    });
    
    if (!response.ok) {
      return null;
    }
    
    return response.json();
  } catch (error) {
    console.error('Failed to fetch blog post:', error);
    return null;
  }
}
```

---

## Next.js 15의 SEO 최적화

### 1. Metadata API 기본 사용법

Next.js 15는 새로운 Metadata API를 통해 더욱 직관적인 SEO 설정을 제공합니다.

#### 정적 메타데이터
```typescript
// app/blog/page.tsx
import { Metadata } from 'next';

export const metadata: Metadata = {
  title: '블로그 | My Website',
  description: '최신 기술 트렌드와 개발 노하우를 공유하는 블로그',
  keywords: ['Next.js', 'React', 'TypeScript', '웹개발'],
  authors: [{ name: 'John Doe', url: 'https://johndoe.com' }],
  robots: {
    index: true,
    follow: true,
    googleBot: {
      index: true,
      follow: true,
      'max-video-preview': -1,
      'max-image-preview': 'large',
      'max-snippet': -1,
    },
  },
};

export default function BlogList() {
  return <div>블로그 목록</div>;
}
```

#### 동적 메타데이터
```typescript
// app/blog/[slug]/page.tsx
import { Metadata } from 'next';
import { getBlogPost } from '@/lib/blog';
import { notFound } from 'next/navigation';

interface BlogPostProps {
  params: { slug: string };
}

export async function generateMetadata(
  { params }: BlogPostProps
): Promise<Metadata> {
  const post = await getBlogPost(params.slug);
  
  if (!post) {
    return {
      title: '포스트를 찾을 수 없습니다',
    };
  }
  
  return {
    title: `${post.title} | My Blog`,
    description: post.content.substring(0, 160),
    keywords: post.tags,
    authors: [{ name: post.author }],
    openGraph: {
      title: post.title,
      description: post.content.substring(0, 160),
      type: 'article',
      publishedTime: post.publishedAt,
      authors: [post.author],
      tags: post.tags,
      url: `https://myblog.com/blog/${post.slug}`,
      images: [
        {
          url: `https://myblog.com/api/og?title=${encodeURIComponent(post.title)}`,
          width: 1200,
          height: 630,
          alt: post.title,
        },
      ],
    },
    twitter: {
      card: 'summary_large_image',
      title: post.title,
      description: post.content.substring(0, 160),
      images: [`https://myblog.com/api/og?title=${encodeURIComponent(post.title)}`],
    },
    alternates: {
      canonical: `https://myblog.com/blog/${post.slug}`,
    },
  };
}

export default async function BlogPost({ params }: BlogPostProps) {
  const post = await getBlogPost(params.slug);
  
  if (!post) {
    notFound();
  }
  
  return (
    <article>
      <h1>{post.title}</h1>
      <p>작성자: {post.author}</p>
      <p>발행일: {new Date(post.publishedAt).toLocaleDateString('ko-KR')}</p>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </article>
  );
}
```

### 2. 구조화된 데이터 (JSON-LD)

```typescript
// components/StructuredData.tsx
interface BlogPostStructuredDataProps {
  post: BlogPost;
}

export function BlogPostStructuredData({ post }: BlogPostStructuredDataProps) {
  const structuredData = {
    '@context': 'https://schema.org',
    '@type': 'BlogPosting',
    headline: post.title,
    description: post.content.substring(0, 160),
    author: {
      '@type': 'Person',
      name: post.author,
    },
    datePublished: post.publishedAt,
    dateModified: post.publishedAt,
    mainEntityOfPage: {
      '@type': 'WebPage',
      '@id': `https://myblog.com/blog/${post.slug}`,
    },
    publisher: {
      '@type': 'Organization',
      name: 'My Blog',
      logo: {
        '@type': 'ImageObject',
        url: 'https://myblog.com/logo.png',
      },
    },
    keywords: post.tags.join(', '),
  };

  return (
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{ __html: JSON.stringify(structuredData) }}
    />
  );
}
```

---

## Metadata API 활용

### 1. 고급 메타데이터 설정

```typescript
// app/blog/[slug]/page.tsx
export async function generateMetadata(
  { params, searchParams }: BlogPostProps
): Promise<Metadata> {
  const post = await getBlogPost(params.slug);
  
  if (!post) {
    return {
      title: '포스트를 찾을 수 없습니다',
      robots: { index: false, follow: false },
    };
  }
  
  const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://myblog.com';
  const ogImageUrl = `${baseUrl}/api/og?title=${encodeURIComponent(post.title)}&author=${encodeURIComponent(post.author)}`;
  
  return {
    title: {
      default: post.title,
      template: '%s | My Blog',
    },
    description: post.content.substring(0, 160) + '...',
    keywords: post.tags,
    
    // Open Graph
    openGraph: {
      type: 'article',
      locale: 'ko_KR',
      siteName: 'My Blog',
      title: post.title,
      description: post.content.substring(0, 160),
      url: `${baseUrl}/blog/${post.slug}`,
      images: [
        {
          url: ogImageUrl,
          width: 1200,
          height: 630,
          alt: post.title,
          type: 'image/png',
        },
      ],
      publishedTime: post.publishedAt,
      authors: [post.author],
      tags: post.tags,
    },
    
    // Twitter Card
    twitter: {
      card: 'summary_large_image',
      site: '@myblog',
      creator: '@myblog',
      title: post.title,
      description: post.content.substring(0, 160),
      images: [ogImageUrl],
    },
    
    // Canonical URL
    alternates: {
      canonical: `${baseUrl}/blog/${post.slug}`,
      languages: {
        'ko-KR': `${baseUrl}/ko/blog/${post.slug}`,
        'en-US': `${baseUrl}/en/blog/${post.slug}`,
      },
    },
    
    // Robots
    robots: {
      index: true,
      follow: true,
      nocache: false,
      googleBot: {
        index: true,
        follow: true,
        noimageindex: false,
        'max-video-preview': -1,
        'max-image-preview': 'large',
        'max-snippet': -1,
      },
    },
    
    // 기타 메타태그
    category: 'technology',
    classification: 'blog',
    referrer: 'origin-when-cross-origin',
    formatDetection: {
      email: false,
      address: false,
      telephone: false,
    },
  };
}
```

### 2. 동적 OG 이미지 생성

```typescript
// app/api/og/route.tsx
import { ImageResponse } from 'next/og';
import { NextRequest } from 'next/server';

export const runtime = 'edge';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const title = searchParams.get('title') || 'My Blog';
  const author = searchParams.get('author') || 'Anonymous';

  return new ImageResponse(
    (
      <div
        style={{
          height: '100%',
          width: '100%',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          backgroundColor: '#1a1a1a',
          fontSize: 60,
          fontWeight: 700,
        }}
      >
        <div style={{ color: 'white', marginBottom: 20 }}>{title}</div>
        <div style={{ color: '#888', fontSize: 30 }}>by {author}</div>
      </div>
    ),
    {
      width: 1200,
      height: 630,
    }
  );
}
```

---

## 실습: 블로그 상세 페이지 구현

이제 실제로 Material-UI를 사용하여 완전한 블로그 상세 페이지를 구현해보겠습니다.

### 1. 프로젝트 구조 설정

```
src/
├── app/
│   ├── blog/
│   │   ├── [slug]/
│   │   │   └── page.tsx
│   │   └── page.tsx
│   ├── globals.css
│   ├── layout.tsx
│   └── page.tsx
├── components/
│   ├── BlogCard.tsx
│   ├── BlogContent.tsx
│   ├── BlogHeader.tsx
│   └── StructuredData.tsx
├── lib/
│   ├── blog.ts
│   └── utils.ts
└── types/
    └── blog.ts
```

### 2. 타입 정의

```typescript
// types/blog.ts
export interface BlogPost {
  id: string;
  slug: string;
  title: string;
  content: string;
  excerpt: string;
  author: {
    name: string;
    avatar: string;
    bio: string;
  };
  publishedAt: string;
  updatedAt: string;
  tags: string[];
  category: string;
  readTime: number;
  featured: boolean;
  coverImage?: string;
}

export interface BlogPostsResponse {
  posts: BlogPost[];
  totalCount: number;
  hasMore: boolean;
}
```

### 3. 데이터 패칭 로직

```typescript
// lib/blog.ts
import { BlogPost, BlogPostsResponse } from '@/types/blog';

// 모든 블로그 포스트 가져오기
export async function getBlogPosts(
  page: number = 1,
  limit: number = 10
): Promise<BlogPostsResponse> {
  try {
    const response = await fetch(
      `${process.env.API_BASE_URL}/posts?page=${page}&limit=${limit}`,
      {
        next: { 
          revalidate: 300, // 5분마다 재검증
          tags: ['blog-posts'] 
        },
      }
    );
    
    if (!response.ok) {
      throw new Error('Failed to fetch blog posts');
    }
    
    return response.json();
  } catch (error) {
    console.error('Error fetching blog posts:', error);
    return {
      posts: [],
      totalCount: 0,
      hasMore: false,
    };
  }
}

// 특정 블로그 포스트 가져오기
export async function getBlogPost(slug: string): Promise<BlogPost | null> {
  try {
    const response = await fetch(
      `${process.env.API_BASE_URL}/posts/${slug}`,
      {
        next: { 
          revalidate: 3600, // 1시간마다 재검증
          tags: [`blog-post-${slug}`] 
        },
      }
    );
    
    if (!response.ok) {
      if (response.status === 404) {
        return null;
      }
      throw new Error('Failed to fetch blog post');
    }
    
    return response.json();
  } catch (error) {
    console.error('Error fetching blog post:', error);
    return null;
  }
}

// 관련 포스트 가져오기
export async function getRelatedPosts(
  slug: string, 
  category: string, 
  limit: number = 3
): Promise<BlogPost[]> {
  try {
    const response = await fetch(
      `${process.env.API_BASE_URL}/posts/related?slug=${slug}&category=${category}&limit=${limit}`,
      {
        next: { revalidate: 3600 },
      }
    );
    
    if (!response.ok) {
      throw new Error('Failed to fetch related posts');
    }
    
    const data = await response.json();
    return data.posts || [];
  } catch (error) {
    console.error('Error fetching related posts:', error);
    return [];
  }
}

// 정적 경로 생성을 위한 모든 slug 가져오기
export async function getAllBlogSlugs(): Promise<string[]> {
  try {
    const response = await fetch(`${process.env.API_BASE_URL}/posts/slugs`);
    
    if (!response.ok) {
      throw new Error('Failed to fetch blog slugs');
    }
    
    const data = await response.json();
    return data.slugs || [];
  } catch (error) {
    console.error('Error fetching blog slugs:', error);
    return [];
  }
}
```

### 4. 블로그 헤더 컴포넌트

```typescript
// components/BlogHeader.tsx
'use client';

import {
  Box,
  Typography,
  Avatar,
  Chip,
  Stack,
  Divider,
  useTheme,
} from '@mui/material';
import {
  AccessTime as AccessTimeIcon,
  CalendarToday as CalendarIcon,
  Person as PersonIcon,
} from '@mui/icons-material';
import { BlogPost } from '@/types/blog';

interface BlogHeaderProps {
  post: BlogPost;
}

export default function BlogHeader({ post }: BlogHeaderProps) {
  const theme = useTheme();
  
  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('ko-KR', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
  };

  return (
    <Box sx={{ mb: 4 }}>
      {/* 카테고리 */}
      <Chip
        label={post.category}
        color="primary"
        size="small"
        sx={{ mb: 2 }}
      />
      
      {/* 제목 */}
      <Typography
        variant="h1"
        component="h1"
        sx={{
          fontSize: { xs: '2rem', md: '3rem' },
          fontWeight: 'bold',
          lineHeight: 1.2,
          mb: 2,
        }}
      >
        {post.title}
      </Typography>
      
      {/* 부제목/요약 */}
      <Typography
        variant="h2"
        component="p"
        sx={{
          fontSize: '1.2rem',
          fontWeight: 400,
          color: theme.palette.text.secondary,
          mb: 3,
          lineHeight: 1.5,
        }}
      >
        {post.excerpt}
      </Typography>
      
      {/* 메타 정보 */}
      <Stack
        direction={{ xs: 'column', sm: 'row' }}
        spacing={2}
        alignItems={{ xs: 'flex-start', sm: 'center' }}
        sx={{ mb: 3 }}
      >
        {/* 작성자 정보 */}
        <Stack direction="row" spacing={1} alignItems="center">
          <Avatar
            src={post.author.avatar}
            alt={post.author.name}
            sx={{ width: 32, height: 32 }}
          >
            <PersonIcon />
          </Avatar>
          <Typography variant="body2" fontWeight={500}>
            {post.author.name}
          </Typography>
        </Stack>
        
        <Divider orientation="vertical" flexItem sx={{ display: { xs: 'none', sm: 'block' } }} />
        
        {/* 발행일 */}
        <Stack direction="row" spacing={0.5} alignItems="center">
          <CalendarIcon fontSize="small" color="action" />
          <Typography variant="body2" color="text.secondary">
            {formatDate(post.publishedAt)}
          </Typography>
        </Stack>
        
        {/* 읽기 시간 */}
        <Stack direction="row" spacing={0.5} alignItems="center">
          <AccessTimeIcon fontSize="small" color="action" />
          <Typography variant="body2" color="text.secondary">
            {post.readTime}분 읽기
          </Typography>
        </Stack>
      </Stack>
      
      {/* 태그 */}
      <Stack direction="row" spacing={1} flexWrap="wrap" useFlexGap>
        {post.tags.map((tag) => (
          <Chip
            key={tag}
            label={`#${tag}`}
            variant="outlined"
            size="small"
            sx={{ fontSize: '0.75rem' }}
          />
        ))}
      </Stack>
      
      <Divider sx={{ mt: 3 }} />
    </Box>
  );
}
```

### 5. 블로그 콘텐츠 컴포넌트

```typescript
// components/BlogContent.tsx
'use client';

import {
  Box,
  Paper,
  Typography,
  useTheme,
} from '@mui/material';
import { styled } from '@mui/material/styles';

const ContentWrapper = styled(Box)(({ theme }) => ({
  '& h1, & h2, & h3, & h4, & h5, & h6': {
    marginTop: theme.spacing(3),
    marginBottom: theme.spacing(2),
    fontWeight: 600,
  },
  '& h1': {
    fontSize: '2rem',
    borderBottom: `2px solid ${theme.palette.primary.main}`,
    paddingBottom: theme.spacing(1),
  },
  '& h2': {
    fontSize: '1.5rem',
    color: theme.palette.primary.main,
  },
  '& h3': {
    fontSize: '1.25rem',
  },
  '& p': {
    marginBottom: theme.spacing(2),
    lineHeight: 1.8,
    fontSize: '1rem',
  },
  '& pre': {
    backgroundColor: theme.palette.grey[100],
    padding: theme.spacing(2),
    borderRadius: theme.shape.borderRadius,
    overflow: 'auto',
    marginBottom: theme.spacing(2),
  },
  '& code': {
    backgroundColor: theme.palette.grey[100],
    padding: '2px 4px',
    borderRadius: 4,
    fontSize: '0.875rem',
    fontFamily: 'Monaco, Consolas, monospace',
  },
  '& blockquote': {
    borderLeft: `4px solid ${theme.palette.primary.main}`,
    paddingLeft: theme.spacing(2),
    margin: theme.spacing(2, 0),
    fontStyle: 'italic',
    backgroundColor: theme.palette.grey[50],
    padding: theme.spacing(1, 2),
  },
  '& ul, & ol': {
    paddingLeft: theme.spacing(3),
    marginBottom: theme.spacing(2),
  },
  '& li': {
    marginBottom: theme.spacing(0.5),
  },
  '& img': {
    maxWidth: '100%',
    height: 'auto',
    borderRadius: theme.shape.borderRadius,
    marginBottom: theme.spacing(2),
  },
  '& a': {
    color: theme.palette.primary.main,
    textDecoration: 'none',
    '&:hover': {
      textDecoration: 'underline',
    },
  },
}));

interface BlogContentProps {
  content: string;
}

export default function BlogContent({ content }: BlogContentProps) {
  const theme = useTheme();
  
  return (
    <Paper 
      elevation={0} 
      sx={{ 
        p: { xs: 2, md: 4 },
        borderRadius: 2,
        backgroundColor: 'transparent',
      }}
    >
      <ContentWrapper>
        <div dangerouslySetInnerHTML={{ __html: content }} />
      </ContentWrapper>
    </Paper>
  );
}
```

### 6. 블로그 카드 컴포넌트 (관련 포스트용)

```typescript
// components/BlogCard.tsx
'use client';

import {
  Card,
  CardContent,
  CardMedia,
  Typography,
  Chip,
  Stack,
  Box,
  Avatar,
  CardActionArea,
} from '@mui/material';
import {
  AccessTime as AccessTimeIcon,
  CalendarToday as CalendarIcon,
} from '@mui/icons-material';
import { BlogPost } from '@/types/blog';
import Link from 'next/link';

interface BlogCardProps {
  post: BlogPost;
  compact?: boolean;
}

export default function BlogCard({ post, compact = false }: BlogCardProps) {
  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('ko-KR', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };

  return (
    <Card 
      sx={{ 
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        transition: 'transform 0.2s, box-shadow 0.2s',
        '&:hover': {
          transform: 'translateY(-4px)',
          boxShadow: 4,
        },
      }}
    >
      <CardActionArea component={Link} href={`/blog/${post.slug}`} sx={{ flexGrow: 1 }}>
        {/* 커버 이미지 */}
        {post.coverImage && (
          <CardMedia
            component="img"
            height={compact ? 120 : 200}
            image={post.coverImage}
            alt={post.title}
            sx={{ objectFit: 'cover' }}
          />
        )}
        
        <CardContent sx={{ flexGrow: 1, display: 'flex', flexDirection: 'column' }}>
          {/* 카테고리 */}
          <Chip
            label={post.category}
            size="small"
            color="primary"
            sx={{ alignSelf: 'flex-start', mb: 1 }}
          />
          
          {/* 제목 */}
          <Typography
            variant={compact ? "h6" : "h5"}
            component="h3"
            sx={{
              fontWeight: 600,
              mb: 1,
              display: '-webkit-box',
              WebkitLineClamp: 2,
              WebkitBoxOrient: 'vertical',
              overflow: 'hidden',
              lineHeight: 1.3,
            }}
          >
            {post.title}
          </Typography>
          
          {/* 요약 */}
          <Typography
            variant="body2"
            color="text.secondary"
            sx={{
              mb: 2,
              flexGrow: 1,
              display: '-webkit-box',
              WebkitLineClamp: compact ? 2 : 3,
              WebkitBoxOrient: 'vertical',
              overflow: 'hidden',
              lineHeight: 1.5,
            }}
          >
            {post.excerpt}
          </Typography>
          
          {/* 메타 정보 */}
          <Stack spacing={1}>
            {/* 작성자 */}
            <Stack direction="row" spacing={1} alignItems="center">
              <Avatar
                src={post.author.avatar}
                alt={post.author.name}
                sx={{ width: 24, height: 24 }}
              />
              <Typography variant="caption" fontWeight={500}>
                {post.author.name}
              </Typography>
            </Stack>
            
            {/* 날짜와 읽기 시간 */}
            <Stack direction="row" spacing={2} alignItems="center">
              <Stack direction="row" spacing={0.5} alignItems="center">
                <CalendarIcon fontSize="small" sx={{ fontSize: '0.8rem' }} />
                <Typography variant="caption" color="text.secondary">
                  {formatDate(post.publishedAt)}
                </Typography>
              </Stack>
              
              <Stack direction="row" spacing={0.5} alignItems="center">
                <AccessTimeIcon fontSize="small" sx={{ fontSize: '0.8rem' }} />
                <Typography variant="caption" color="text.secondary">
                  {post.readTime}분
                </Typography>
              </Stack>
            </Stack>
          </Stack>
        </CardContent>
      </CardActionArea>
    </Card>
  );
}
```

### 7. 블로그 상세 페이지 구현

```typescript
// app/blog/[slug]/page.tsx
import { Metadata } from 'next';
import { notFound } from 'next/navigation';
import {
  Container,
  Box,
  Typography,
  Grid,
  Divider,
  Stack,
  Paper,
} from '@mui/material';
import BlogHeader from '@/components/BlogHeader';
import BlogContent from '@/components/BlogContent';
import BlogCard from '@/components/BlogCard';
import StructuredData from '@/components/StructuredData';
import { getBlogPost, getRelatedPosts, getAllBlogSlugs } from '@/lib/blog';
import { BlogPost } from '@/types/blog';

interface BlogPostPageProps {
  params: { slug: string };
}

// 메타데이터 생성
export async function generateMetadata(
  { params }: BlogPostPageProps
): Promise<Metadata> {
  const post = await getBlogPost(params.slug);
  
  if (!post) {
    return {
      title: '포스트를 찾을 수 없습니다',
      description: '요청하신 블로그 포스트를 찾을 수 없습니다.',
      robots: { index: false, follow: false },
    };
  }
  
  const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://myblog.com';
  const ogImageUrl = `${baseUrl}/api/og?title=${encodeURIComponent(post.title)}&author=${encodeURIComponent(post.author.name)}`;
  
  return {
    title: `${post.title} | My Blog`,
    description: post.excerpt,
    keywords: post.tags,
    authors: [{ name: post.author.name }],
    
    openGraph: {
      type: 'article',
      locale: 'ko_KR',
      siteName: 'My Blog',
      title: post.title,
      description: post.excerpt,
      url: `${baseUrl}/blog/${post.slug}`,
      images: [
        {
          url: post.coverImage || ogImageUrl,
          width: 1200,
          height: 630,
          alt: post.title,
        },
      ],
      publishedTime: post.publishedAt,
      modifiedTime: post.updatedAt,
      authors: [post.author.name],
      tags: post.tags,
      section: post.category,
    },
    
    twitter: {
      card: 'summary_large_image',
      title: post.title,
      description: post.excerpt,
      images: [post.coverImage || ogImageUrl],
    },
    
    alternates: {
      canonical: `${baseUrl}/blog/${post.slug}`,
    },
    
    other: {
      'article:published_time': post.publishedAt,
      'article:modified_time': post.updatedAt,
      'article:author': post.author.name,
      'article:section': post.category,
      'article:tag': post.tags.join(', '),
    },
  };
}

// 정적 경로 생성 (ISG)
export async function generateStaticParams() {
  const slugs = await getAllBlogSlugs();
  
  return slugs.map((slug) => ({
    slug: slug,
  }));
}

export default async function BlogPostPage({ params }: BlogPostPageProps) {
  const post = await getBlogPost(params.slug);
  
  if (!post) {
    notFound();
  }
  
  // 관련 포스트 가져오기
  const relatedPosts = await getRelatedPosts(post.slug, post.category, 3);
  
  return (
    <>
      {/* 구조화된 데이터 */}
      <StructuredData post={post} />
      
      <Container maxWidth="lg" sx={{ py: 4 }}>
        <Grid container spacing={4}>
          {/* 메인 콘텐츠 */}
          <Grid item xs={12} md={8}>
            <Box component="article">
              {/* 블로그 헤더 */}
              <BlogHeader post={post} />
              
              {/* 커버 이미지 */}
              {post.coverImage && (
                <Box sx={{ mb: 4 }}>
                  <img
                    src={post.coverImage}
                    alt={post.title}
                    style={{
                      width: '100%',
                      height: '400px',
                      objectFit: 'cover',
                      borderRadius: '8px',
                    }}
                  />
                </Box>
              )}
              
              {/* 블로그 내용 */}
              <BlogContent content={post.content} />
              
              {/* 작성자 정보 */}
              <Paper
                elevation={1}
                sx={{
                  p: 3,
                  mt: 4,
                  backgroundColor: 'grey.50',
                  borderRadius: 2,
                }}
              >
                <Stack direction="row" spacing={2} alignItems="flex-start">
                  <img
                    src={post.author.avatar}
                    alt={post.author.name}
                    style={{
                      width: 64,
                      height: 64,
                      borderRadius: '50%',
                    }}
                  />
                  <Box flexGrow={1}>
                    <Typography variant="h6" fontWeight={600} gutterBottom>
                      {post.author.name}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      {post.author.bio}
                    </Typography>
                  </Box>
                </Stack>
              </Paper>
            </Box>
          </Grid>
          
          {/* 사이드바 */}
          <Grid item xs={12} md={4}>
            <Box sx={{ position: 'sticky', top: 24 }}>
              {/* 관련 포스트 */}
              {relatedPosts.length > 0 && (
                <Box>
                  <Typography variant="h5" fontWeight={600} gutterBottom>
                    관련 포스트
                  </Typography>
                  <Divider sx={{ mb: 3 }} />
                  <Stack spacing={2}>
                    {relatedPosts.map((relatedPost) => (
                      <BlogCard
                        key={relatedPost.id}
                        post={relatedPost}
                        compact
                      />
                    ))}
                  </Stack>
                </Box>
              )}
            </Box>
          </Grid>
        </Grid>
      </Container>
    </>
  );
}
```

### 8. 블로그 목록 페이지

```typescript
// app/blog/page.tsx
import { Metadata } from 'next';
import {
  Container,
  Typography,
  Grid,
  Box,
  Chip,
  Stack,
} from '@mui/material';
import BlogCard from '@/components/BlogCard';
import { getBlogPosts } from '@/lib/blog';

export const metadata: Metadata = {
  title: 'Blog | My Website',
  description: '최신 기술 트렌드와 개발 노하우를 공유하는 블로그',
  keywords: ['Next.js', 'React', 'TypeScript', '웹개발', '블로그'],
  openGraph: {
    title: 'Blog | My Website',
    description: '최신 기술 트렌드와 개발 노하우를 공유하는 블로그',
    type: 'website',
    url: 'https://myblog.com/blog',
  },
};

interface BlogPageProps {
  searchParams: {
    page?: string;
    category?: string;
  };
}

export default async function BlogPage({ searchParams }: BlogPageProps) {
  const page = parseInt(searchParams.page || '1', 10);
  const category = searchParams.category;
  
  const { posts, totalCount, hasMore } = await getBlogPosts(page, 12);
  
  // 카테고리별 필터링
  const filteredPosts = category 
    ? posts.filter(post => post.category === category)
    : posts;
  
  // 모든 카테고리 추출
  const allCategories = Array.from(
    new Set(posts.map(post => post.category))
  );
  
  return (
    <Container maxWidth="lg" sx={{ py: 4 }}>
      {/* 페이지 헤더 */}
      <Box textAlign="center" mb={6}>
        <Typography
          variant="h1"
          component="h1"
          sx={{
            fontSize: { xs: '2.5rem', md: '3.5rem' },
            fontWeight: 'bold',
            mb: 2,
          }}
        >
          블로그
        </Typography>
        <Typography
          variant="h2"
          component="p"
          sx={{
            fontSize: '1.2rem',
            color: 'text.secondary',
            fontWeight: 400,
            maxWidth: 600,
            mx: 'auto',
          }}
        >
          개발과 기술에 대한 인사이트를 공유합니다
        </Typography>
      </Box>
      
      {/* 카테고리 필터 */}
      <Box mb={4}>
        <Stack direction="row" spacing={1} flexWrap="wrap" useFlexGap>
          <Chip
            label="전체"
            color={!category ? "primary" : "default"}
            component="a"
            href="/blog"
            clickable
          />
          {allCategories.map((cat) => (
            <Chip
              key={cat}
              label={cat}
              color={category === cat ? "primary" : "default"}
              component="a"
              href={`/blog?category=${encodeURIComponent(cat)}`}
              clickable
            />
          ))}
        </Stack>
      </Box>
      
      {/* 블로그 포스트 그리드 */}
      <Grid container spacing={3}>
        {filteredPosts.map((post) => (
          <Grid item xs={12} sm={6} md={4} key={post.id}>
            <BlogCard post={post} />
          </Grid>
        ))}
      </Grid>
      
      {/* 빈 상태 */}
      {filteredPosts.length === 0 && (
        <Box textAlign="center" py={8}>
          <Typography variant="h6" color="text.secondary">
            {category 
              ? `'${category}' 카테고리에 포스트가 없습니다.`
              : '포스트가 없습니다.'
            }
          </Typography>
        </Box>
      )}
      
      {/* 페이지네이션 정보 */}
      {hasMore && (
        <Box textAlign="center" mt={6}>
          <Typography variant="body2" color="text.secondary">
            총 {totalCount}개의 포스트 중 {filteredPosts.length}개를 표시하고 있습니다.
          </Typography>
        </Box>
      )}
    </Container>
  );
}
```

### 9. 구조화된 데이터 컴포넌트 완성

```typescript
// components/StructuredData.tsx
import { BlogPost } from '@/types/blog';

interface StructuredDataProps {
  post: BlogPost;
}

export default function StructuredData({ post }: StructuredDataProps) {
  const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://myblog.com';
  
  const articleStructuredData = {
    '@context': 'https://schema.org',
    '@type': 'BlogPosting',
    '@id': `${baseUrl}/blog/${post.slug}`,
    headline: post.title,
    description: post.excerpt,
    image: post.coverImage ? [post.coverImage] : [],
    datePublished: post.publishedAt,
    dateModified: post.updatedAt,
    author: {
      '@type': 'Person',
      name: post.author.name,
      image: post.author.avatar,
      description: post.author.bio,
    },
    publisher: {
      '@type': 'Organization',
      name: 'My Blog',
      logo: {
        '@type': 'ImageObject',
        url: `${baseUrl}/logo.png`,
        width: 200,
        height: 60,
      },
    },
    mainEntityOfPage: {
      '@type': 'WebPage',
      '@id': `${baseUrl}/blog/${post.slug}`,
    },
    keywords: post.tags.join(', '),
    articleSection: post.category,
    wordCount: post.content.split(' ').length,
    timeRequired: `PT${post.readTime}M`,
    inLanguage: 'ko-KR',
    isAccessibleForFree: true,
    creativeWorkStatus: 'Published',
  };
  
  const breadcrumbStructuredData = {
    '@context': 'https://schema.org',
    '@type': 'BreadcrumbList',
    itemListElement: [
      {
        '@type': 'ListItem',
        position: 1,
        name: '홈',
        item: baseUrl,
      },
      {
        '@type': 'ListItem',
        position: 2,
        name: '블로그',
        item: `${baseUrl}/blog`,
      },
      {
        '@type': 'ListItem',
        position: 3,
        name: post.title,
        item: `${baseUrl}/blog/${post.slug}`,
      },
    ],
  };
  
  const websiteStructuredData = {
    '@context': 'https://schema.org',
    '@type': 'WebSite',
    '@id': `${baseUrl}/#website`,
    url: baseUrl,
    name: 'My Blog',
    description: '개발과 기술에 대한 인사이트를 공유하는 블로그',
    potentialAction: {
      '@type': 'SearchAction',
      target: {
        '@type': 'EntryPoint',
        urlTemplate: `${baseUrl}/search?q={search_term_string}`,
      },
      'query-input': 'required name=search_term_string',
    },
  };

  return (
    <>
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{
          __html: JSON.stringify(articleStructuredData),
        }}
      />
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{
          __html: JSON.stringify(breadcrumbStructuredData),
        }}
      />
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{
          __html: JSON.stringify(websiteStructuredData),
        }}
      />
    </>
  );
}
```

---

## 고급 SEO 테크닉

### 1. 사이트맵 생성

```typescript
// app/sitemap.ts
import { MetadataRoute } from 'next';
import { getBlogPosts } from '@/lib/blog';

export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
  const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://myblog.com';
  
  // 블로그 포스트 가져오기
  const { posts } = await getBlogPosts(1, 1000); // 모든 포스트
  
  // 정적 페이지
  const staticPages = [
    {
      url: baseUrl,
      lastModified: new Date(),
      changeFrequency: 'daily' as const,
      priority: 1,
    },
    {
      url: `${baseUrl}/blog`,
      lastModified: new Date(),
      changeFrequency: 'daily' as const,
      priority: 0.8,
    },
    {
      url: `${baseUrl}/about`,
      lastModified: new Date(),
      changeFrequency: 'monthly' as const,
      priority: 0.6,
    },
  ];
  
  // 블로그 포스트 페이지
  const blogPages = posts.map((post) => ({
    url: `${baseUrl}/blog/${post.slug}`,
    lastModified: new Date(post.updatedAt),
    changeFrequency: 'weekly' as const,
    priority: 0.7,
  }));
  
  return [...staticPages, ...blogPages];
}
```

### 2. 로봇 파일 생성

```typescript
// app/robots.ts
import { MetadataRoute } from 'next';

export default function robots(): MetadataRoute.Robots {
  const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://myblog.com';
  
  return {
    rules: [
      {
        userAgent: '*',
        allow: '/',
        disallow: ['/api/', '/admin/', '/_next/'],
      },
      {
        userAgent: 'Googlebot',
        allow: '/',
        disallow: ['/api/', '/admin/'],
      },
    ],
    sitemap: `${baseUrl}/sitemap.xml`,
    host: baseUrl,
  };
}
```

### 3. RSS 피드 생성

```typescript
// app/feed.xml/route.ts
import { NextResponse } from 'next/server';
import { getBlogPosts } from '@/lib/blog';

export async function GET() {
  const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://myblog.com';
  const { posts } = await getBlogPosts(1, 50);
  
  const rssXml = `<?xml version="1.0" encoding="UTF-8"?>
    <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
      <channel>
        <title>My Blog</title>
        <description>개발과 기술에 대한 인사이트를 공유하는 블로그</description>
        <link>${baseUrl}</link>
        <language>ko-KR</language>
        <lastBuildDate>${new Date().toUTCString()}</lastBuildDate>
        <atom:link href="${baseUrl}/feed.xml" rel="self" type="application/rss+xml"/>
        ${posts
          .map(
            (post) => `
            <item>
              <title><![CDATA[${post.title}]]></title>
              <description><![CDATA[${post.excerpt}]]></description>
              <link>${baseUrl}/blog/${post.slug}</link>
              <guid isPermaLink="true">${baseUrl}/blog/${post.slug}</guid>
              <pubDate>${new Date(post.publishedAt).toUTCString()}</pubDate>
              <author>${post.author.name}</author>
              <category>${post.category}</category>
            </item>
          `
          )
          .join('')}
      </channel>
    </rss>`;

  return new NextResponse(rssXml, {
    headers: {
      'Content-Type': 'application/xml',
      'Cache-Control': 'public, s-maxage=86400, stale-while-revalidate=43200',
    },
  });
}
```

---

## 성능 최적화

### 1. 이미지 최적화

```typescript
// components/OptimizedImage.tsx
import Image from 'next/image';
import { useState } from 'react';
import { Skeleton, Box } from '@mui/material';

interface OptimizedImageProps {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  priority?: boolean;
  className?: string;
}

export default function OptimizedImage({
  src,
  alt,
  width = 800,
  height = 400,
  priority = false,
  className,
}: OptimizedImageProps) {
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false);

  return (
    <Box position="relative" width="100%" height={height}>
      {isLoading && !hasError && (
        <Skeleton 
          variant="rectangular" 
          width="100%" 
          height={height}
          sx={{ position: 'absolute', top: 0, left: 0 }}
        />
      )}
      
      {!hasError && (
        <Image
          src={src}
          alt={alt}
          width={width}
          height={height}
          priority={priority}
          className={className}
          style={{
            objectFit: 'cover',
            borderRadius: '8px',
            opacity: isLoading ? 0 : 1,
            transition: 'opacity 0.3s',
          }}
          onLoad={() => setIsLoading(false)}
          onError={() => {
            setIsLoading(false);
            setHasError(true);
          }}
          sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
        />
      )}
      
      {hasError && (
        <Box
          display="flex"
          alignItems="center"
          justifyContent="center"
          width="100%"
          height={height}
          bgcolor="grey.100"
          borderRadius={1}
        >
          이미지를 불러올 수 없습니다
        </Box>
      )}
    </Box>
  );
}
```

### 2. 코드 스플리팅과 지연 로딩

```typescript
// components/LazyBlogCard.tsx
'use client';

import dynamic from 'next/dynamic';
import { Skeleton, Card, CardContent } from '@mui/material';

// 동적 import로 컴포넌트 지연 로딩
const BlogCard = dynamic(() => import('./BlogCard'), {
  loading: () => (
    <Card sx={{ height: '100%' }}>
      <Skeleton variant="rectangular" height={200} />
      <CardContent>
        <Skeleton variant="text" height={30} />
        <Skeleton variant="text" height={20} />
        <Skeleton variant="text" height={20} width="60%" />
      </CardContent>
    </Card>
  ),
});

export default BlogCard;
```

### 3. 성능 모니터링 설정

```typescript
// lib/analytics.ts
export function reportWebVitals(metric: any) {
  if (process.env.NODE_ENV === 'production') {
    // Google Analytics 4로 Web Vitals 데이터 전송
    if (typeof window !== 'undefined' && (window as any).gtag) {
      (window as any).gtag('event', metric.name, {
        custom_map: {
          metric_id: 'custom_metric_id',
        },
        value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value),
        event_category: 'Web Vitals',
        event_label: metric.id,
        non_interaction: true,
      });
    }
    
    // 콘솔에서 성능 지표 확인 (개발 시에만)
    console.log('Web Vitals:', metric);
  }
}

// app/layout.tsx에서 사용
// export { reportWebVitals } from '@/lib/analytics';
```

---

## 마무리

### 주요 학습 내용 요약

1. **동적 라우팅**: App Router를 활용한 현대적인 라우팅 시스템
2. **SEO 최적화**: Metadata API를 통한 완벽한 메타데이터 관리
3. **구조화된 데이터**: JSON-LD를 활용한 검색 엔진 최적화
4. **성능 최적화**: 이미지 최적화, 코드 스플리팅, 지연 로딩
5. **TypeScript 활용**: 타입 안전성을 통한 안정적인 개발

### 실습 프로젝트 완성도

이 교재를 통해 다음과 같은 완전한 블로그 시스템을 구축할 수 있습니다:

- ✅ 동적 라우팅을 활용한 블로그 상세 페이지
- ✅ SEO 최적화된 메타데이터 자동 생성
- ✅ Material-UI 기반의 현대적인 UI/UX
- ✅ TypeScript로 작성된 타입 안전한 코드
- ✅ Turbopack을 활용한 빠른 개발 환경
- ✅ 성능 최적화된 프로덕션 준비 코드

### 다음 단계

이 교재를 완료한 후에는 다음과 같은 고급 기능들을 추가로 학습해보세요:

- 댓글 시스템 구현
- 검색 기능 추가
- 다국어 지원 (i18n)
- PWA 기능 구현
- 실시간 분석 도구 연동

### 참고 자료

- [Next.js 15 공식 문서](https://nextjs.org/docs)
- [Material-UI 공식 문서](https://mui.com/getting-started/installation/)
- [TypeScript 핸드북](https://www.typescriptlang.org/docs/)
- [SEO 모범 사례](https://developers.google.com/search/docs/fundamentals/seo-starter-guide)