# 04. 컴포넌트 구조화

---

## 1) 부모-자식 컴포넌트 데이터 전달

### 단방향 데이터 흐름(One-way Data Flow)

* **상태(state)는 소유자(부모)에게 두고**, 자식은 **props로 데이터**와 \*\*콜백(이벤트 핸들러)\*\*을 받습니다.
* 자식이 무언가를 “변경”하고 싶다면 **부모가 내려준 콜백을 호출**하여 부모 상태를 갱신합니다.
  (Vue에서 `emit`으로 부모에게 알리던 흐름과 유사)

### 구조화 원칙

1. **상태의 주인 정하기**: 여러 자식이 같은 데이터를 쓰면 **공통 부모**에 상태를 둡니다(상태 끌어올리기).
2. **작게 쪼개기**: Presentational(보이는 것) vs Container(데이터/로직) 분리.
3. **계약 명확화**: 컴포넌트 간 인터페이스(Props 타입)를 명확히 정의.

---

## 2) props drilling과 컴포넌트 재사용

### Props Drilling이란?

* 깊은 하위 컴포넌트에 전달하려고 **부모 → 중간 → 자식**으로 같은 props를 **여러 단계** 내려 보내는 현상.
* 문제: **재사용성/가독성 저하**, 중간 컴포넌트가 **불필요한 책임**을 가짐.

### 최소화 팁

* **상태 위치 재검토**: 더 위/아래로 옮기면 drilling이 줄어드는지 확인.
* **액션 번들링**: 여러 핸들러를 각각 넘기지 말고 `actions`라는 **객체로 묶어** 전달.
* **컴포지션(Children & Compound Components)**: 레이아웃을 맡는 래퍼가 내부 구조를 제어하지 않게.
* (예고) 더 복잡하면 **Context**나 전역 상태 관리 도입(다음 파트에서).

---

## 3) 실습: 간단한 ToDo List (Vite + React + TypeScript)

### 3-1) 프로젝트 초기화 (Vite)

```bash
# React + SWC + TypeScript 템플릿
npm create vite@latest react-todo-ts -- --template react-swc-ts
cd react-todo-ts
npm install
npm run dev
```

### 3-2) 폴더 구조(예시)

```
src/
├─ App.tsx
├─ main.tsx
└─ components/
   ├─ TodoApp.tsx
   ├─ TodoForm.tsx
   ├─ TodoList.tsx
   ├─ TodoItem.tsx
   ├─ TodoFilters.tsx
   └─ EmptyState.tsx
```

---

### 3-3) 타입 설계

* \*\*부모(TodoApp)\*\*가 상태를 소유하고, 자식들은 **데이터 + 액션 콜백**을 props로 받습니다.

```ts
// src/components/TodoApp.tsx (상단에 함께 선언하거나 별도 types.ts로 분리 가능)
export type Todo = {
  id: string;
  text: string;
  done: boolean;
  createdAt: number;
};

export type Filter = 'all' | 'active' | 'completed';

export type TodoActions = {
  add: (text: string) => void;
  toggle: (id: string) => void;
  remove: (id: string) => void;
  clearCompleted: () => void;
};
```

---

### 3-4) 컨테이너 컴포넌트 (상태의 주인)

```tsx
// src/components/TodoApp.tsx
import { useMemo, useState } from 'react';
import { Todo, Filter, TodoActions } from './TodoApp.types'; // 위 타입을 분리했다면 사용
import TodoForm from './TodoForm';
import TodoList from './TodoList';
import TodoFilters from './TodoFilters';
import EmptyState from './EmptyState';

function createTodo(text: string): Todo {
  return {
    id: crypto.randomUUID(),   // 브라우저 지원. (구버전은 uuid 패키지 사용)
    text,
    done: false,
    createdAt: Date.now(),
  };
}

export default function TodoApp() {
  const [todos, setTodos] = useState<Todo[]>([]);
  const [filter, setFilter] = useState<Filter>('all');

  const actions: TodoActions = {
    add: (text: string) =>
      setTodos(prev => [createTodo(text), ...prev]),
    toggle: (id: string) =>
      setTodos(prev =>
        prev.map(t => (t.id === id ? { ...t, done: !t.done } : t))
      ),
    remove: (id: string) =>
      setTodos(prev => prev.filter(t => t.id !== id)),
    clearCompleted: () =>
      setTodos(prev => prev.filter(t => !t.done)),
  };

  const filtered = useMemo(() => {
    switch (filter) {
      case 'active':
        return todos.filter(t => !t.done);
      case 'completed':
        return todos.filter(t => t.done);
      default:
        return todos;
    }
  }, [todos, filter]);

  const completedCount = todos.filter(t => t.done).length;

  return (
    <section style={{ maxWidth: 520, margin: '0 auto', padding: 24 }}>
      <h1 style={{ marginBottom: 16 }}>ToDo List</h1>

      {/* 입력(자식) ← 부모 액션 중 add만 전달 */}
      <TodoForm onAdd={actions.add} />

      {/* 필터(자식) ← 현재 필터와 변경 콜백 전달 */}
      <TodoFilters
        current={filter}
        onChange={setFilter}
        onClearCompleted={actions.clearCompleted}
        completedCount={completedCount}
      />

      {/* 목록(자식) ← 데이터와 toggle/remove 액션 번들 전달 */}
      {filtered.length > 0 ? (
        <TodoList todos={filtered} actions={actions} />
      ) : (
        <EmptyState />
      )}
    </section>
  );
}
```

> 포인트
>
> * **부모가 상태 소유**: `todos`, `filter`
> * **자식은 UI + 이벤트 알림**: add/toggle/remove/clear를 **콜백으로 호출**
> * **Props Drilling 완화**: `actions` 객체로 묶어 하위로 전달

---

### 3-5) 입력 폼 (Controlled Component)

```tsx
// src/components/TodoForm.tsx
import { useState } from 'react';

type Props = {
  onAdd: (text: string) => void;
};

export default function TodoForm({ onAdd }: Props) {
  const [text, setText] = useState<string>('');

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const value = text.trim();
    if (!value) return;
    onAdd(value);
    setText('');
  };

  return (
    <form onSubmit={handleSubmit} style={{ display: 'flex', gap: 8 }}>
      <input
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="할 일을 입력 후 Enter"
        aria-label="새 할 일"
        style={{ flex: 1 }}
      />
      <button type="submit">추가</button>
    </form>
  );
}
```

---

### 3-6) 필터/상태 정보

```tsx
// src/components/TodoFilters.tsx
import type { Filter } from './TodoApp'; // 혹은 별도 types import

type Props = {
  current: Filter;
  onChange: (f: Filter) => void;
  onClearCompleted: () => void;
  completedCount: number;
};

const filters: Filter[] = ['all', 'active', 'completed'];

export default function TodoFilters({
  current, onChange, onClearCompleted, completedCount
}: Props) {
  return (
    <div style={{ display: 'flex', gap: 8, alignItems: 'center', margin: '12px 0' }}>
      <div style={{ display: 'flex', gap: 4 }}>
        {filters.map(f => (
          <button
            key={f}
            onClick={() => onChange(f)}
            aria-pressed={current === f}
            style={{
              padding: '4px 8px',
              border: current === f ? '2px solid #333' : '1px solid #ccc',
              borderRadius: 8
            }}
          >
            {f}
          </button>
        ))}
      </div>
      <span style={{ marginLeft: 'auto', fontSize: 12, color: '#666' }}>
        완료: {completedCount}
      </span>
      <button onClick={onClearCompleted}>완료 삭제</button>
    </div>
  );
}
```

---

### 3-7) 목록 & 아이템

```tsx
// src/components/TodoList.tsx
import type { Todo, TodoActions } from './TodoApp';
import TodoItem from './TodoItem';

type Props = {
  todos: Todo[];
  actions: Pick<TodoActions, 'toggle' | 'remove'>; // 필요한 액션만 내려도 OK
};

export default function TodoList({ todos, actions }: Props) {
  return (
    <ul style={{ listStyle: 'none', padding: 0, margin: 0, display: 'grid', gap: 8 }}>
      {todos.map(todo => (
        <TodoItem key={todo.id} todo={todo} actions={actions} />
      ))}
    </ul>
  );
}
```

```tsx
// src/components/TodoItem.tsx
import type { Todo, TodoActions } from './TodoApp';

type Props = {
  todo: Todo;
  actions: Pick<TodoActions, 'toggle' | 'remove'>;
};

export default function TodoItem({ todo, actions }: Props) {
  return (
    <li
      style={{
        border: '1px solid #eee',
        borderRadius: 8,
        padding: 8,
        display: 'flex',
        alignItems: 'center',
        gap: 8
      }}
    >
      <input
        type="checkbox"
        checked={todo.done}
        onChange={() => actions.toggle(todo.id)}
        aria-label={`${todo.text} 완료 토글`}
      />
      <span style={{ flex: 1, textDecoration: todo.done ? 'line-through' : 'none' }}>
        {todo.text}
      </span>
      <button onClick={() => actions.remove(todo.id)} aria-label="삭제">🗑️</button>
    </li>
  );
}
```

---

### 3-8) 빈 상태 뷰(재사용 가능한 프레젠테이셔널 컴포넌트)

```tsx
// src/components/EmptyState.tsx
type Props = {
  title?: string;
  description?: string;
};

export default function EmptyState({
  title = '할 일이 없습니다',
  description = '상단 입력창에 새 할 일을 추가하세요.'
}: Props) {
  return (
    <div
      style={{
        border: '1px dashed #ccc',
        borderRadius: 12,
        padding: 24,
        textAlign: 'center',
        color: '#666',
        marginTop: 16
      }}
    >
      <h3 style={{ margin: 0 }}>{title}</h3>
      <p style={{ margin: '8px 0 0' }}>{description}</p>
    </div>
  );
}
```

---

### 3-9) 진입점

```tsx
// src/App.tsx
import TodoApp from './components/TodoApp';

export default function App() {
  return (
    <main style={{ fontFamily: 'system-ui', lineHeight: 1.5 }}>
      <TodoApp />
    </main>
  );
}
```

```tsx
// src/main.tsx
import { createRoot } from 'react-dom/client';
import App from './App';
import './index.css';

createRoot(document.getElementById('root')!).render(<App />);
```

> 여기까지 실행하면 **추가/토글/삭제/필터링/완료 일괄 삭제**까지 가능한 간단한 ToDo가 완성됩니다.
>
> * **부모-자식 데이터 전달**: `TodoApp` → `TodoForm`, `TodoList`, `TodoFilters`
> * **props drilling 최소화**: `actions` 번들 전달
> * **컴포넌트 재사용**: `EmptyState`는 다른 리스트 화면에도 그대로 사용 가능

---

## 4) 실습 미션 (Hands-on)

1. **편집(Editing) 기능 추가**

   * `TodoItem`에 “편집” 버튼을 추가하고, 인라인 입력으로 내용 수정 후 Enter로 저장.
   * 타입: `edit: (id: string, text: string) => void`를 `TodoActions`에 추가.

2. **로컬 스토리지 영속화**

   * `useEffect`로 `todos` 변경 시 `localStorage`에 저장, 초기 로딩 때 복원.
   * (힌트) JSON 직렬화/역직렬화 + `try/catch`.

3. **성능 미세 최적화**

   * `TodoItem`을 `React.memo`로 감싸고, 핸들러는 `useCallback`으로 메모이즈.
   * 바뀐 아이템만 리렌더되는지 React DevTools로 확인.

4. **프레젠테이셔널 컴포넌트로 분리**

   * `TodoList`를 데이터 없는 “UI 전용”으로 복제(예: `TodoListView`), 스토리북 도입을 가정하고 다양한 상태를 미리보기.

---

## 5) 예상 질문(Q\&A)

**Q1. 어떤 기준으로 상태를 부모에 둘지/자식에 둘지 결정하나요?**
A. **여러 자식이 공유**하거나 **부모가 제어해야 하는** 데이터는 부모가 소유합니다. 특정 컴포넌트 안에서만 쓰이면 그 **컴포넌트 내부**에 두세요.

**Q2. props drilling을 언제까지 감내하고, 언제 Context를 써야 하나요?**
A. 2\~3단계 정도에서 불편이 커지거나, 동일 데이터를 **다수의 하위 트리**에 뿌려야 하면 Context를 고려합니다. 이번 장은 **액션 번들링과 구조 재검토**로 우선 완화하는 단계입니다.

**Q3. `actions` 객체로 묶는 방식의 장점은?**
A. 전달 prop의 **개수를 줄여 가독성**이 좋아지고, 하위 컴포넌트가 필요 없는 액션을 **선택적으로 Pick**해 쓸 수 있습니다.

**Q4. 리스트 key로 index를 쓰면 무엇이 문제인가요?**
A. 항목 추가/삭제/정렬 시 **키 안정성**이 깨져 잘못된 재사용/리렌더링이 발생할 수 있습니다. 가능하면 **고유 id**를 사용하세요.

**Q5. 입력 폼은 왜 Controlled가 권장되나요?**
A. 값의 단일 진실 공급원(SSOT)이 **state**로 모여 **검증/제출/리셋**을 체계적으로 처리할 수 있습니다.
