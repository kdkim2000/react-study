# 03. 상태관리(State)와 이벤트 처리

---

## 1) useState 훅 사용하기

### 핵심 요약

* `useState<T>(initial)`는 \*\*상태값(state)\*\*과 \*\*설정 함수(setState)\*\*를 반환합니다.
* **이전 상태를 기준으로 업데이트**할 때는 `setState(prev => …)` (함수형 업데이트)를 사용합니다.
* 객체/배열 상태는 \*\*불변성(immutable)\*\*을 지켜 **새 객체/배열을 생성**하여 업데이트합니다.

### 최소 예제: 카운터 (함수형 업데이트)

```tsx
// src/components/CounterButton.tsx
import { useState } from 'react';

export default function CounterButton() {
  const [count, setCount] = useState<number>(0);

  const inc = () => setCount((c) => c + 1);
  const dec = () => setCount((c) => Math.max(0, c - 1));
  const reset = () => setCount(0);

  return (
    <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
      <button onClick={dec}>-</button>
      <strong>{count}</strong>
      <button onClick={inc}>+</button>
      <button onClick={reset}>reset</button>
    </div>
  );
}
```

---

## 2) 이벤트 핸들링 (onClick, onChange 등)

### 타입 안전한 이벤트

* 클릭: `React.MouseEvent<HTMLButtonElement>`
* 입력 변화: `React.ChangeEvent<HTMLInputElement>`
* 폼 제출: `React.FormEvent<HTMLFormElement>`

### 예제: 입력 필드와 onChange

```tsx
// src/components/ControlledInput.tsx
import { useState } from 'react';

export default function ControlledInput() {
  const [text, setText] = useState<string>("");

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setText(e.target.value);
  };

  return (
    <div style={{ display: 'grid', gap: 8 }}>
      <input
        value={text}
        onChange={handleChange}
        placeholder="메모를 입력하세요"
      />
      <p>글자 수: {text.length}</p>
    </div>
  );
}
```

---

## 3) 양방향 바인딩 구현하기 (Controlled Components)

> Vue의 `v-model`에 해당하는 패턴이 **Controlled Component**입니다.
> 입력값의 \*\*단일 진실 공급원(SSOT)\*\*을 **state**로 두고, `value`와 `onChange`로 동기화합니다.

```tsx
// src/components/ProfileForm.tsx
import { useState } from 'react';

type Role = 'admin' | 'user' | 'guest';

type FormState = {
  name: string;
  age: number | '';     // 빈 문자열 허용 (입력 지울 때)
  role: Role;
  agree: boolean;
};

const initialForm: FormState = {
  name: '',
  age: '',
  role: 'user',
  agree: false,
};

export default function ProfileForm() {
  const [form, setForm] = useState<FormState>(initialForm);

  function handleInputChange(e: React.ChangeEvent<HTMLInputElement>) {
    const { name, value, type, checked } = e.target;
    setForm((prev) => ({
      ...prev,
      [name]:
        type === 'checkbox'
          ? checked
          : name === 'age'
            ? (value === '' ? '' : Number(value))
            : value,
    }));
  }

  function handleSelectChange(e: React.ChangeEvent<HTMLSelectElement>) {
    const value = e.target.value as Role;
    setForm((prev) => ({ ...prev, role: value }));
  }

  function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    // 실제 환경에서는 여기서 서버로 제출
    alert(`제출 데이터\n${JSON.stringify(form, null, 2)}`);
  }

  const canSubmit =
    form.name.trim() !== '' &&
    typeof form.age === 'number' &&
    form.age > 0 &&
    form.agree;

  const reset = () => setForm(initialForm);

  return (
    <form onSubmit={handleSubmit} style={{ display: 'grid', gap: 12, maxWidth: 420 }}>
      <label>
        이름
        <input
          name="name"
          value={form.name}
          onChange={handleInputChange}
          placeholder="홍길동"
        />
      </label>

      <label>
        나이
        <input
          name="age"
          type="number"
          value={form.age}
          onChange={handleInputChange}
          placeholder="0"
          min={0}
        />
      </label>

      <label>
        역할(Role)
        <select name="role" value={form.role} onChange={handleSelectChange}>
          <option value="user">user</option>
          <option value="admin">admin</option>
          <option value="guest">guest</option>
        </select>
      </label>

      <label style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
        <input
          name="agree"
          type="checkbox"
          checked={form.agree}
          onChange={handleInputChange}
        />
        개인정보 처리에 동의합니다.
      </label>

      <div style={{ display: 'flex', gap: 8 }}>
        <button type="submit" disabled={!canSubmit}>제출</button>
        <button type="button" onClick={reset}>초기화</button>
      </div>

      <pre style={{ background: '#f7f7f7', padding: 12, borderRadius: 8 }}>
{JSON.stringify(form, null, 2)}
      </pre>
    </form>
  );
}
```

---

## 4) 프로젝트 구성 (Vite + React + TS)

> 새로 시작한다면 아래처럼 초기화하세요.

```bash
# Vite 프로젝트 생성 (React + SWC + TypeScript)
npm create vite@latest react-state-ts -- --template react-swc-ts
cd react-state-ts
npm install
npm run dev
```

폴더 구조 예시:

```
react-state-ts/
├─ index.html
├─ package.json
├─ src/
│  ├─ main.tsx
│  ├─ App.tsx
│  └─ components/
│     ├─ CounterButton.tsx
│     ├─ ControlledInput.tsx
│     └─ ProfileForm.tsx
└─ vite.config.ts
```

`src/main.tsx`

```tsx
import { createRoot } from 'react-dom/client';
import App from './App';
import './index.css';

createRoot(document.getElementById('root')!).render(<App />);
```

`src/App.tsx`

```tsx
import CounterButton from './components/CounterButton';
import ControlledInput from './components/ControlledInput';
import ProfileForm from './components/ProfileForm';

export default function App() {
  return (
    <main style={{ padding: 24, display: 'grid', gap: 24 }}>
      <h1>03. 상태관리와 이벤트 처리 (TS)</h1>
      <section>
        <h2>useState 기본</h2>
        <CounterButton />
      </section>

      <section>
        <h2>onChange로 제어되는 입력</h2>
        <ControlledInput />
      </section>

      <section>
        <h2>양방향 바인딩: 폼</h2>
        <ProfileForm />
      </section>
    </main>
  );
}
```

---

## 5) 실습 미션 (Hands-on)

1. **증가 단위 커스터마이즈**

   * `CounterButton`에 `step` prop(기본 1)을 추가하고, `+/-`가 `step`만큼 움직이도록 수정.

2. **입력 검증**

   * `ProfileForm`에서 이름은 2자 이상, 나이는 15\~99 범위만 허용하도록 `canSubmit`을 보강.
   * 조건 불만족 시 버튼 비활성화 + 메시지 표시.

3. **배열/객체 상태 업데이트**

   * `ProfileForm`에 취미 체크박스 그룹(예: 음악, 독서, 운동)을 추가하여
     `hobbies: string[]`를 상태로 관리. 체크/해제 시 `setForm`으로 **새 배열**을 만들어 업데이트.

4. **재사용 가능한 입력 훅 만들기(선택)**

   * `useInput` 커스텀 훅을 만들어 텍스트 입력의 `value/onChange` 바인딩을 캡슐화.
   * 숫자 입력용 `useNumberInput` 변형도 만들어 보기.

---

## 6) 자주 하는 실수 & 베스트 프랙티스

* **직접 변경 금지**: `form.age++` 같은 **직접 변이**는 금지. `setForm(prev => ({ ...prev, age: prev.age + 1 }))`
* **함수형 업데이트**: 이전 값 기반 업데이트는 항상 `(prev) => …` 형태 사용.
* **파생 상태 저장 지양**: 렌더링 때 계산 가능한 값은 **state로 두지 말고** 렌더에서 계산.
* **Controlled 우선**: 폼은 가급적 **Controlled**로 관리(디버깅/검증/제출에 유리).

---

## 7) 예상 질문(Q\&A)

**Q1. `setState` 직후에 상태가 곧바로 바뀌지 않는 것처럼 보이는 이유는?**
A. React가 \*\*배치(batching)\*\*하여 렌더링을 최적화하기 때문입니다. 직후 값을 읽어야 한다면 **함수형 업데이트**나 `useEffect`로 반영 시점을 다루세요.

**Q2. 객체/배열 상태를 업데이트할 때 반드시 새 객체/배열이 필요한가요?**
A. 네. **불변성**을 유지해야 React가 변경을 감지하고 렌더링합니다. `map/filter/spread([...])` 등을 사용하세요.

**Q3. `onChange`에서 이벤트 타입은 꼭 써야 하나요?**
A. TypeScript에서는 추천합니다. `React.ChangeEvent<HTMLInputElement>`처럼 구체 타입을 쓰면 오타나 잘못된 속성 접근을 예방할 수 있습니다.

**Q4. 숫자 입력에서 빈 문자열 처리가 번거롭습니다.**
A. 폼 입력은 문자열로 들어오므로 **빈 문자열**과 **숫자**를 함께 다루는 유니온 타입(`number | ''`)이 실용적입니다. 제출 전에 스키마 검증으로 정리하세요.

**Q5. 형제 컴포넌트 간 상태 공유는 어떻게 하나요?**
A. \*\*상태 끌어올리기(lift state up)\*\*로 공통 부모에서 관리하거나, 전역 공유가 필요하면 다음 장의 **Context** 또는 외부 상태관리 라이브러리를 고려합니다.

---
