# 16. 인증 & 세션 관리

구성: **설명 → 실습 코드(TypeScript, Vite 기준) → 실습 미션 → 예상 질문(Q\&A)**

> 이 장은 **Vite(React + TS)** 기준으로 진행합니다.
> 단, “NextAuth.js”는 현재 **Auth.js**로 이름이 바뀌었고, Next.js 외에서도 쓸 수 있게 \*\*Express용 어댑터(@auth/express)\*\*가 제공됩니다(실험적). 아래 **B트랙**에서 Vite 프론트엔드 + Express(Auth.js) 조합을 함께 실습합니다. ([NextAuth][1], [Auth.js][2])

---

## 1) 인증·세션 개념 한눈에

* **세션 기반**: 서버가 세션을 저장(메모리/DB), 브라우저는 세션 ID를 **쿠키**로 보유. 전통적인 방식.
* **JWT 기반**: 서버가 **서명된 토큰**을 발급, 클라이언트가 토큰을 들고 다님. 액세스 토큰(짧게) + 리프레시 토큰(길게) 조합이 일반적.
* **Auth.js(구 NextAuth.js)**: OAuth(구글/깃허브 등)·이메일·Credentials 등 다수 **프로바이더**를 통합. \*\*Express용(@auth/express)\*\*은 공식이지만 *현재 실험적(experimental)* 상태이며, **REST 엔드포인트(예: `/auth/signin`, `/auth/signout`, `/auth/session` 등)와 CSRF 토큰 처리**를 제공합니다. ([Auth.js][2])

---

## 2) 실습 목표

A. **JWT 직접 구현(추천 입문)** — Vite + Express로 **로그인/로그아웃/보호 API**를 만들고, **HttpOnly 쿠키 + 짧은 액세스 토큰 + 리프레시 토큰** 패턴을 체험
B. **Auth.js(NextAuth) for Express** — Vite 프런트에서 **@auth/express** REST 엔드포인트를 호출하는 흐름 맛보기(깃허브 OAuth 또는 Credentials)

---

## 3) 트랙 A — “JWT로 직접 인증” (Vite + Express)

### 3-1) 프로젝트 생성 & 의존성

```bash
# 프론트(React + TS)
npm create vite@latest auth-jwt-vite -- --template react-swc-ts
cd auth-jwt-vite

# 백엔드(Express + TS)
npm i express cors cookie-parser jsonwebtoken bcryptjs zod
npm i -D ts-node-dev @types/node @types/express @types/cookie-parser @types/cors @types/jsonwebtoken @types/bcryptjs
```

`package.json`에 서버 스크립트 추가(간단 샘플):

```json
{
  "scripts": {
    "dev": "vite",
    "server": "ts-node-dev --respawn --transpile-only server/index.ts"
  }
}
```

### 3-2) 서버 코드(Express) — **HttpOnly 쿠키 + JWT**

**`server/index.ts`**

```ts
import express from "express";
import cors from "cors";
import cookieParser from "cookie-parser";
import jwt from "jsonwebtoken";
import bcrypt from "bcryptjs";

// ===== 설정 =====
const app = express();
app.use(express.json());
app.use(cookieParser());
app.use(cors({ origin: "http://localhost:5173", credentials: true }));

const ACCESS_SECRET = "dev_access_secret_change_me";
const REFRESH_SECRET = "dev_refresh_secret_change_me";
const ACCESS_TTL = "15m";   // 액세스 토큰 유효기간(짧게)
const REFRESH_TTL = "7d";   // 리프레시 토큰 유효기간(길게)

// 데모 사용자(실무에선 DB 사용)
const users = [
  { id: "u1", email: "user@example.com", name: "데모유저", passwordHash: bcrypt.hashSync("1234", 10) },
];

// ===== 유틸 =====
function signAccessToken(userId: string) {
  return jwt.sign({ sub: userId }, ACCESS_SECRET, { expiresIn: ACCESS_TTL });
}
function signRefreshToken(userId: string) {
  return jwt.sign({ sub: userId, type: "refresh" }, REFRESH_SECRET, { expiresIn: REFRESH_TTL });
}
function authGuard(req: any, res: any, next: any) {
  const auth = req.headers.authorization || "";
  const token = auth.startsWith("Bearer ") ? auth.slice(7) : null;
  if (!token) return res.status(401).json({ error: "missing access token" });
  try {
    const payload = jwt.verify(token, ACCESS_SECRET) as { sub: string };
    (req as any).userId = payload.sub;
    next();
  } catch {
    return res.status(401).json({ error: "invalid/expired token" });
  }
}

// ===== 라우트 =====
app.post("/api/login", async (req, res) => {
  const { email, password } = req.body ?? {};
  const user = users.find((u) => u.email === email);
  if (!user || !bcrypt.compareSync(password, user.passwordHash)) {
    return res.status(401).json({ error: "invalid credentials" });
  }
  const accessToken = signAccessToken(user.id);
  const refreshToken = signRefreshToken(user.id);
  // HttpOnly 쿠키에 리프레시 토큰 저장(브라우저 JS에서 접근 불가)
  res.cookie("refresh_token", refreshToken, {
    httpOnly: true,
    sameSite: "lax",
    secure: false, // 프로덕션에선 true(HTTPS)
    path: "/api",
    maxAge: 7 * 24 * 60 * 60 * 1000,
  });
  res.status(200).json({ accessToken, user: { id: user.id, email: user.email, name: user.name } });
});

app.post("/api/refresh", (req, res) => {
  const rt = req.cookies?.refresh_token;
  if (!rt) return res.status(401).json({ error: "missing refresh token" });
  try {
    const payload = jwt.verify(rt, REFRESH_SECRET) as { sub: string; type: string };
    if (payload.type !== "refresh") throw new Error();
    const accessToken = signAccessToken(payload.sub);
    // 필요 시 리프레시 토큰 회전도 구현
    return res.status(200).json({ accessToken });
  } catch {
    return res.status(401).json({ error: "invalid refresh token" });
  }
});

app.post("/api/logout", (_req, res) => {
  res.clearCookie("refresh_token", { path: "/api" });
  res.status(204).end();
});

app.get("/api/me", authGuard, (req, res) => {
  const me = users.find((u) => u.id === (req as any).userId);
  if (!me) return res.status(404).json({ error: "not found" });
  res.json({ id: me.id, email: me.email, name: me.name });
});

app.listen(5174, () => console.log("API on http://localhost:5174"));
```

> **개발 편의**: Vite 프록시로 `/api` 요청을 Express로 우회합니다.

**`vite.config.ts`**

```ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: { "/api": "http://localhost:5174" }, // /api → Express
  },
});
```

### 3-3) 프런트 코드(React, Vite) — **로그인/토큰 자동갱신**

**`src/auth.tsx`** (간단 컨텍스트)

```tsx
import React, { createContext, useContext, useEffect, useState } from "react";

type User = { id: string; email: string; name: string };
type AuthCtx = {
  user: User | null;
  accessToken: string | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  api: <T = any>(input: RequestInfo, init?: RequestInit) => Promise<T>; // 토큰 자동첨부+갱신
};
const Ctx = createContext<AuthCtx>(null as any);
export const useAuth = () => useContext(Ctx);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [accessToken, setAccessToken] = useState<string | null>(null);

  async function login(email: string, password: string) {
    const res = await fetch("/api/login", {
      method: "POST",
      credentials: "include", // 쿠키(리프레시) 보내기
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ email, password }),
    });
    if (!res.ok) throw new Error("로그인 실패");
    const data = await res.json();
    setAccessToken(data.accessToken);
    setUser(data.user);
  }

  async function logout() {
    await fetch("/api/logout", { method: "POST", credentials: "include" });
    setUser(null);
    setAccessToken(null);
  }

  async function refresh() {
    const r = await fetch("/api/refresh", { method: "POST", credentials: "include" });
    if (!r.ok) throw new Error("리프레시 실패");
    const d = await r.json();
    setAccessToken(d.accessToken);
    return d.accessToken as string;
  }

  // API 호출 래퍼: 401이면 리프레시 후 1회 재시도
  const api = async <T,>(input: RequestInfo, init: RequestInit = {}) => {
    const run = async (token?: string) =>
      fetch(input, {
        ...init,
        headers: { ...(init.headers || {}), ...(token ? { Authorization: `Bearer ${token}` } : {}) },
      });
    let res = await run(accessToken || undefined);
    if (res.status === 401) {
      const newToken = await refresh();
      res = await run(newToken);
    }
    if (!res.ok) throw new Error(`API ${res.status}`);
    return (await res.json()) as T;
  };

  // 새로고침 후에도 세션 복구(리프레시 토큰이 있으면 /me 재검)
  useEffect(() => {
    (async () => {
      try {
        const t = await refresh();
        await api<User>("/api/me", { method: "GET" });
        setAccessToken(t);
      } catch { /* not signed in */ }
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return <Ctx.Provider value={{ user, accessToken, login, logout, api }}>{children}</Ctx.Provider>;
}
```

**`src/App.tsx`** (UI)

```tsx
import { useAuth, AuthProvider } from "./auth";
import { useState } from "react";

function Inner() {
  const { user, login, logout, api } = useAuth();
  const [email, setEmail] = useState("user@example.com");
  const [password, setPassword] = useState("1234");
  const [me, setMe] = useState<any>(null);

  return (
    <main style={{ maxWidth: 720, margin: "0 auto", padding: 24, display: "grid", gap: 12 }}>
      <h1>JWT 로그인 데모</h1>

      {user ? (
        <>
          <div>안녕하세요, <b>{user.name}</b>님</div>
          <div style={{ display: "flex", gap: 8 }}>
            <button onClick={() => api("/api/me").then(setMe)}>내 정보 조회</button>
            <button onClick={logout}>로그아웃</button>
          </div>
          <pre className="card">{me ? JSON.stringify(me, null, 2) : "데이터 없음"}</pre>
        </>
      ) : (
        <form onSubmit={(e) => { e.preventDefault(); login(email, password).catch(alert); }}
              className="card" style={{ display: "grid", gap: 8 }}>
          <input value={email} onChange={(e) => setEmail(e.target.value)} placeholder="email" />
          <input value={password} onChange={(e) => setPassword(e.target.value)} placeholder="password" type="password" />
          <button type="submit">로그인</button>
        </form>
      )}
    </main>
  );
}

export default function App() {
  return <AuthProvider><Inner /></AuthProvider>;
}
```

> 핵심 포인트
>
> * **리프레시 토큰은 HttpOnly 쿠키**로, **액세스 토큰은 메모리 상태**로 관리(로컬스토리지 보관 지양).
> * API 응답이 `401`이면 `/api/refresh`로 재발급 → **1회 재시도**.
> * 프로덕션에선 `secure: true(HTTPS)`·도메인 설정·토큰 회전·로그아웃 블랙리스트 등을 강화하세요.
> * JWT/쿠키/세션 개념은 Express·Node 보안 가이드와 함께 복습하면 좋습니다. ([Auth0 Developer Center][3], [apidog][4])

---

## 4) 트랙 B — “Auth.js(NextAuth) for Express + Vite”

> **왜?** OAuth(구글/깃허브 등) 도입이 쉽고, 세션·CSRF·콜백 흐름을 **Auth.js가 표준화**합니다. *단, `@auth/express`는 현재 실험적*. 설치/사용과 **REST 엔드포인트 + CSRF 토큰** 요구사항을 꼭 확인하세요. ([Auth.js][2])

### 4-1) 서버 설치 & 베이스 마운트

```bash
npm i @auth/express dotenv
```

**`server/auth.ts`**

```ts
import express from "express";
import { ExpressAuth } from "@auth/express";
// OAuth: GitHub 예시(자격 필요) 또는 Credentials 로그인
import GitHub from "@auth/express/providers/github";
// import Credentials from "@auth/express/providers/credentials"; // Credentials도 가능
import "dotenv/config";

export const app = express();
app.set("trust proxy", true); // 프록시 뒤에서 https 감지
app.use("/auth/*", ExpressAuth({
  // providers: [Credentials({ /* authorize 구현 */ })],
  providers: [GitHub],
  secret: process.env.AUTH_SECRET, // 최소 32자 난수
}));
```

**중요 포인트**

* `AUTH_SECRET` 환경변수 필수, `openssl rand -hex 32` 등으로 생성.
* 기본 콜백 URL: `http(s)://<origin>/auth/callback/<provider>`
* **사인인/사인아웃은 REST 엔드포인트**로 호출하며, **요청 본문에 CSRF 토큰 포함**이 필요합니다. ([Auth.js][2])

### 4-2) Vite 프론트 — 세션 조회/로그인/로그아웃

**CSRF 토큰 → 로그인 POST → 세션 조회** 흐름(간단 Credentials 가정)

```tsx
// src/authjs.ts
export async function getCsrf() {
  const r = await fetch("/auth/csrf", { credentials: "include" });
  const { csrfToken } = await r.json();
  return csrfToken as string;
}

export async function signinCredentials(email: string, password: string) {
  const csrfToken = await getCsrf();
  const r = await fetch("/auth/signin/credentials", {
    method: "POST",
    credentials: "include",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({
      csrfToken,
      redirect: "false",
      email,
      password
    })
  });
  if (!r.ok) throw new Error("signin failed");
}

export async function signout() {
  const csrfToken = await getCsrf();
  await fetch("/auth/signout", {
    method: "POST",
    credentials: "include",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({ csrfToken, redirect: "false" })
  });
}

// 세션 정보(로그인 여부 확인)
export async function getSession() {
  const r = await fetch("/auth/session", { credentials: "include" });
  return r.ok ? r.json() : null;
}
```

> 위 REST 경로/CSRF 토큰 필요성은 **Auth.js Express 문서** 흐름을 따릅니다(실험적 API). 실제 프로젝트에서 프로바이더/콜백/세션 스키마는 문서 원문을 참조하세요. ([Auth.js][2])

---

## 5) 실습 미션 (Hands-on)

1. **권한 보호 라우트**

   * 트랙 A: `authGuard`를 `/api/admin`에 적용, 일반 계정 접근 시 `403`.
   * 트랙 B: `@auth/express`의 `getSession()`을 미들웨어로 사용해 보호 라우트 구성.

2. **비밀번호 정책 & 검증**

   * 서버: `zod`로 이메일/비밀번호 스키마 검증, 400 응답.
   * 클라이언트: 동일 규칙을 프리체크하여 UX 개선.

3. **토큰 회전/폐기(보안 심화)**

   * 리프레시 토큰을 DB/Redis에 저장하고 **회전 시 이전 토큰 폐기** 로직 추가.

4. **소셜 로그인 도입(트랙 B)**

   * GitHub/Google 앱을 생성하고, `providers`에 추가 → `/auth/signin` UX를 구성.

5. **프로덕션 하드닝**

   * HTTPS + `secure: true`, CSRF 방어 강화, CORS 제한, 레이트 리미트, 브루트포스 차단.

---

## 6) 자주 하는 실수 & 베스트 프랙티스

* **로컬스토리지에 토큰 저장**: XSS에 취약. **액세스 토큰은 메모리**, **리프레시는 HttpOnly 쿠키** 권장.
* **리프레시 무제한 재사용**: 회전(rotate)·폐기 목록(블랙리스트)로 **재사용 공격 방지**.
* **CORS/쿠키 옵션 누락**: `credentials: true` + `sameSite`, `secure` 설정을 환경에 맞춰 정확히.
* **Auth.js Express를 NextAuth와 동일하다고 가정**: **실험적 API**이며 일부 차이가 있습니다. 공식 문서를 꼭 확인하세요. ([Auth.js][2])

---

## 7) 예상 질문(Q\&A)

**Q1. Vite(React)인데 NextAuth를 그대로 쓸 수 있나요?**
A. 라이브러리 자체는 **Auth.js**로 확장되었고, **Express 어댑터**로 Vite 프론트와 조합이 가능합니다(실험적). Next.js 전용 훅/컴포넌트는 그대로 쓰기 어렵고, **REST 엔드포인트 호출** 방식으로 붙입니다. ([GitHub][5], [Auth.js][2])

**Q2. JWT vs 세션, 무엇이 좋나요?**
A. SPA/모바일·게이트웨이 환경에서는 JWT가 편리합니다. 반면 서버 렌더 웹·레거시 시스템은 세션이 단순할 수 있습니다. 팀의 인프라/보안요건에 맞춰 선택하세요(둘 다 가능).

**Q3. CSRF는 왜 필요한가요?**
A. 세션/쿠키 기반 요청은 **자동 전송**되므로, **의도치 않은 요청**을 방지하려고 토큰 기반 검증을 합니다. Auth.js REST 사인인/아웃에도 **CSRF 토큰**을 포함해야 합니다. ([Auth.js][2])

**Q4. 프로덕션에서 꼭 챙길 것?**
A. HTTPS, `secure` 쿠키, 토큰 회전, 입력 검증, 레이트 리미트, 감사 로그, 비밀키 관리(.env/비밀 저장소) 등. Auth0/Express 보안 가이드도 참고하면 도움 됩니다. ([Auth0 Developer Center][3])

---

## 참고/출처

* **NextAuth.js → Auth.js 이행** 안내 및 배경. ([NextAuth][1])
* **@auth/express(공식 Express 통합, 실험적)** — 설치/사용, REST·CSRF, 세션/미들웨어. ([Auth.js][2])
* **Express 보안/인증 베이식 가이드(참고)**. ([Auth0 Developer Center][3], [apidog][4])

---

## 다음 예고

다음 장에서는 **권한(Authorization)** 설계(역할/권한·라우팅 보호·서버/클라이언트 가드·미들웨어)와 **보호 리소스 캐싱 전략**을 다룹니다.

[1]: https://next-auth.js.org/adapters/?utm_source=chatgpt.com "Adapters | NextAuth.js"
[2]: https://authjs.dev/reference/express "Auth.js | Express"
[3]: https://developer.auth0.com/resources/get-started/web-app/express?utm_source=chatgpt.com "Get Started with Express.js: Security and Identity Management"
[4]: https://apidog.com/blog/node-js-express-authentication/?utm_source=chatgpt.com "Node.js Express Authentication: Concepts, Methods & Examples"
[5]: https://github.com/nextauthjs/next-auth/discussions/7974?utm_source=chatgpt.com "Next-Auth client functionality on Vite - GitHub"
