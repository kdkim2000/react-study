# 02. JSX와 컴포넌트 기초

구성: **설명 → 실습 코드 예시 → 실습 미션 → 예상 질문(Q\&A)**
(이전 장에서 만든 `my-react-app`을 그대로 사용합니다.)

---

## 1) JSX 문법 이해

### JSX란?

* **JSX**는 *JavaScript + XML-like* 문법입니다. JS 코드 안에서 마크업을 작성할 수 있게 해줘요.
* 빌드 시 **순수 JavaScript**로 변환되므로 브라우저가 직접 JSX를 이해하는 것은 아닙니다.

### 핵심 규칙

* **표현식 출력**: 중괄호 `{}` 안에서 **표현식**을 쓸 수 있습니다. (숫자, 문자열, 배열, 함수 호출 등)
* **속성 표기**: HTML과 달리 **camelCase**를 사용합니다.

  * `class` → `className`
  * `for` → `htmlFor`
  * 인라인 스타일은 객체: `style={{ color: 'tomato', fontSize: 20 }}`
* **루트 노드**: 컴포넌트는 **하나의 루트**만 반환. 여러 엘리먼트를 반환하려면 **Fragment** `<>...</>` 사용.
* **조건/반복**: JSX 안에서 `if`/`for`는 직접 못 씁니다. 대신 **삼항 연산자**, `&&`, `Array.map()`을 사용.
* **이벤트**: `onClick`, `onChange` 등 **camelCase**로 작성하고 **함수**를 전달합니다.

### 자주 쓰는 패턴 요약

```jsx
{condition ? <A /> : <B />}            // 조건부 렌더링 (삼항)
{condition && <A />}                   // 조건부 렌더링 (AND)
{list.map(item => <li key={item.id}>{item.text}</li>)}  // 리스트 렌더링
```

---

## 2) 함수형 컴포넌트 만들기

### 함수형이 표준

* React는 **함수형 컴포넌트**가 표준입니다. (클래스형은 레거시)
* 컴포넌트 이름은 **PascalCase**로 시작합니다.

```jsx
// src/components/Hello.jsx
export default function Hello() {
  const now = new Date().toLocaleTimeString();
  return (
    <>
      <h2>안녕하세요 👋</h2>
      <p>지금 시각: {now}</p>
    </>
  );
}
```

```jsx
// src/App.jsx
import Hello from './components/Hello';

export default function App() {
  return (
    <main style={{ padding: 24 }}>
      <h1>JSX & 컴포넌트 기초</h1>
      <Hello />
    </main>
  );
}
```

> 팁: React 17+의 **새 JSX 변환** 덕분에 `import React from 'react'`를 파일 상단에 명시하지 않아도 됩니다. (Vite 템플릿 기본 설정)

---

## 3) props와 children 활용

### props 기본

* **props**는 부모가 자식 컴포넌트에 전달하는 **읽기 전용 데이터**입니다.
* 객체 구조분해로 꺼내 쓰는 것이 가독성에 좋아요.

```jsx
// src/components/UserBadge.jsx
export default function UserBadge({ name, role = 'Member' }) {
  return (
    <div style={{ border: '1px solid #ddd', padding: 12, borderRadius: 8 }}>
      <strong>{name}</strong>
      <span style={{ marginLeft: 8, color: '#555' }}>({role})</span>
    </div>
  );
}
```

```jsx
// src/App.jsx
import UserBadge from './components/UserBadge';

export default function App() {
  return (
    <main style={{ padding: 24 }}>
      <h1>props 기본</h1>
      <UserBadge name="김경덕" role="Software Engineer" />
      <UserBadge name="홍길동" /> {/* role 기본값: Member */}
    </main>
  );
}
```

### children으로 레이아웃 구성 (Vue의 slot과 유사)

* React는 **단일 슬롯** 개념인 `children`을 기본 제공합니다.
* **레이아웃/카드/모달** 등 래핑 컴포넌트에서 자주 사용합니다.

```jsx
// src/components/Card.jsx
export default function Card({ title, children, footer }) {
  return (
    <section style={{ border: '1px solid #eee', borderRadius: 12, padding: 16, marginTop: 16 }}>
      {title && <h2 style={{ marginTop: 0 }}>{title}</h2>}
      <div>{children}</div>
      {footer && <div style={{ marginTop: 12, borderTop: '1px solid #f0f0f0', paddingTop: 8 }}>{footer}</div>}
    </section>
  );
}
```

```jsx
// src/App.jsx
import Card from './components/Card';

export default function App() {
  return (
    <main style={{ padding: 24 }}>
      <h1>children & 컴포지션</h1>

      <Card title="공지">
        <p>리액트 스터디는 매주 화/목 19:00에 진행합니다.</p>
      </Card>

      <Card
        title="업무 가이드"
        footer={<small>마지막 업데이트: 2025-08-27</small>}
      >
        <ul>
          <li>PR은 최소 1명 리뷰 후 머지</li>
          <li>Lint 에러 0 유지</li>
          <li>커밋 메시지 규칙: feat/fix/chore 등 prefix</li>
        </ul>
      </Card>
    </main>
  );
}
```

> Vue의 \*\*`<slot>`\*\*에 대응되는 것이 React의 \*\*`children`\*\*입니다.
> Vue의 **이름 있는 슬롯**은 React에서 **별도 prop**을 추가하거나 **Compound Components** 패턴으로 대체합니다(아래 고급 예시).

### (고급) Compound Components 패턴 맛보기

```jsx
// src/components/Panel.jsx
function Panel({ children }) {
  return <div style={{ border: '1px solid #ddd', borderRadius: 8 }}>{children}</div>;
}
function PanelHeader({ children }) {
  return <div style={{ padding: 12, borderBottom: '1px solid #eee', fontWeight: 700 }}>{children}</div>;
}
function PanelBody({ children }) {
  return <div style={{ padding: 12 }}>{children}</div>;
}
function PanelFooter({ children }) {
  return <div style={{ padding: 12, borderTop: '1px solid #eee' }}>{children}</div>;
}

Panel.Header = PanelHeader;
Panel.Body = PanelBody;
Panel.Footer = PanelFooter;

export default Panel;
```

```jsx
// src/App.jsx
import Panel from './components/Panel';

export default function App() {
  return (
    <main style={{ padding: 24 }}>
      <h1>Compound Components</h1>
      <Panel>
        <Panel.Header>프로젝트 알림</Panel.Header>
        <Panel.Body>이번 스프린트 목표는 성능 30% 개선입니다.</Panel.Body>
        <Panel.Footer>담당: FE Chapter</Panel.Footer>
      </Panel>
    </main>
  );
}
```

---

## 4) 실습 코드 예시(통합)

> 아래는 **JSX/컴포넌트/props/children**을 한 번에 사용하는 예시입니다.

```
src/
├─ App.jsx
└─ components/
   ├─ Hello.jsx
   ├─ UserBadge.jsx
   ├─ Card.jsx
   └─ Panel.jsx
```

**포인트**

* `UserBadge`로 **props 기본값/구조분해** 경험
* `Card`로 **children + 커스텀 footer prop** 경험
* `Panel`로 **Compound Components** 구조 맛보기

---

## 5) 실습 미션 (Hands-on)

> 교육 대상자가 **직접 타이핑**하고 **눈으로 결과 확인**하는 것을 목표로 합니다.

1. **조건부 렌더링 연습**

   * `App.jsx`에 `show` state를 만들고 버튼으로 토글하여, `UserBadge` 표시/숨기기 구현.
   * 삼항 연산자와 `&&` 각각으로 구현해 보고 차이를 비교.

2. **목록 렌더링 + key**

   * `const users = [{id:1,name:'A'},{id:2,name:'B'}];`를 만들고 `users.map()`으로 `UserBadge` 목록 출력.
   * `key`를 `user.id`로 지정. 임시로 `index`를 key로 쓰면 어떤 문제가 생길 수 있는지 주석으로 설명.

3. **children 확장**

   * `Card`에 `header` prop을 추가하거나, `Card.Header/Body/Footer` 형태의 compound 구조를 도입해보기.
   * 같은 내용을 두 방식으로 구현해 보고, 팀에서 어떤 방식을 가이드로 채택할지 토론.

4. **(선택) TypeScript 변환**

   * `UserBadge.tsx`로 변경하고 `name: string; role?: string` 타입 지정.
   * `Card`의 `footer`처럼 **ReactNode** 타입을 사용해보기.

---

## 6) 예상 질문(Q\&A)

**Q1. JSX에서 `class` 대신 `className`을 쓰는 이유는?**
A. `class`는 JS 예약어입니다. JSX는 JS 위에서 돌아가므로 \*\*`className`\*\*으로 표기합니다. 비슷하게 `for`는 \*\*`htmlFor`\*\*를 사용합니다.

**Q2. JSX 안에서 `if`나 `for`를 못 쓰는 이유는?**
A. JSX는 **표현식**만 허용합니다. `if`/`for`는 \*\*문(statement)\*\*이라 JSX 중간에 둘 수 없습니다. 대신 **삼항/&&/map**을 사용합니다.

**Q3. Fragment `<>...</>`는 꼭 필요할까요?**
A. 컴포넌트는 **하나의 루트**만 반환해야 합니다. 불필요한 div를 늘리지 않으려면 **Fragment**가 유용합니다.

**Q4. props는 수정하면 안 되나요?**
A. 네. props는 **부모가 준 읽기 전용 데이터**입니다. 자식에서 변경하려면 **부모에 콜백을 전달**해 부모 state를 업데이트하는 패턴을 사용하세요.

**Q5. children과 Vue의 slot 차이는?**
A. 기본 개념은 비슷합니다. React는 기본적으로 \*\*단일 슬롯(children)\*\*만 제공하고, 이름 있는 슬롯은 **별도의 prop**을 쓰거나 **Compound Components**로 해결합니다.

**Q6. key로 index를 쓰면 안 되나요?**
A. 가능은 하지만 **항목 추가/삭제/정렬 시 재조합 오류**나 **원치 않는 리렌더링**을 유발할 수 있습니다. **안정적 고유 ID**를 쓰는 것이 좋습니다.

---
