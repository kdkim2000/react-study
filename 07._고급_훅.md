# 07. 고급 훅

## 1) 훅 핵심 개념 정리

### `useRef`

* **mutable한 값 저장**(렌더와 무관): 값이 바뀌어도 **리렌더링이 일어나지 않음**.
* DOM 엘리먼트 참조, 타이머/웹소켓 핸들 등 **외부 상태 핸들** 보관.
* “이전 값 기억”, “렌더 횟수 측정” 같은 **진단/측정**용으로도 자주 사용.

### `useMemo`

* **비싼 계산 결과**나 **의미 있는 참조 동일성**을 **메모이제이션**.
* 의존성이 바뀌지 않으면 이전 결과(참조)를 재사용 → **불필요한 연산/리렌더** 절감.
* 남용 금지(값이 싸면 굳이 쓰지 않음). **비용 > 이득**이면 제거.

### `useCallback`

* **함수의 참조 동일성 보장**을 위해 사용.
  `useCallback(fn, deps)` ≈ `useMemo(() => fn, deps)`
* `React.memo`로 감싼 자식에게 **안정적인 핸들러**를 내려줄 때 효과.

---

## 2) 성능 최적화 개념 한 눈에

* **리렌더링 원인**: 상위 state 바뀜, props 참조 변경, context 변경 등.
* **최적화 도구 세트**

  * 연산비용↓: `useMemo`(비싼 필터/정렬/파싱 등)
  * 참조안정성↑: `useCallback` + `React.memo(자식)`
  * 불변성 준수: 새 객체/배열 생성으로 **변경 감지** 명확화
  * 리스트 대규모: **가상 스크롤(virtualization)** 라이브러리 고려
* **규칙**: “**먼저 올바르게** → 필요할 때 **국소 최적화**”. 프리마튜어 최적화는 지양.

---

## 3) 실습: 검색 필터링 UI (메모·콜백·레퍼런스 풀코스)

### 3-1) 프로젝트 초기화 (Vite)

```bash
npm create vite@latest react-advanced-hooks-ts -- --template react-swc-ts
cd react-advanced-hooks-ts
npm install
npm run dev
```

### 3-2) 폴더 구조

```
src/
├─ App.tsx
├─ main.tsx
├─ data.ts
├─ utils/
│  └─ highlight.tsx
└─ components/
   ├─ SearchApp.tsx
   ├─ SearchInput.tsx
   ├─ CategorySelect.tsx
   ├─ ResultsList.tsx
   └─ ResultItem.tsx
```

### 3-3) 공통 타입 & 더미 데이터

**`src/data.ts`**

```ts
export type Item = {
  id: string;
  name: string;
  category: 'Framework' | 'Library' | 'Tool';
  price: number;
};

export const items: Item[] = [
  { id: '1', name: 'React', category: 'Library', price: 0 },
  { id: '2', name: 'Vue', category: 'Framework', price: 0 },
  { id: '3', name: 'Next.js', category: 'Framework', price: 0 },
  { id: '4', name: 'Vite', category: 'Tool', price: 0 },
  { id: '5', name: 'Redux Toolkit', category: 'Library', price: 0 },
  { id: '6', name: 'Zustand', category: 'Library', price: 0 },
  { id: '7', name: 'Tailwind CSS', category: 'Tool', price: 0 },
  { id: '8', name: 'TanStack Query', category: 'Library', price: 0 },
  { id: '9', name: 'Vitest', category: 'Tool', price: 0 },
  { id: '10', name: 'SWR', category: 'Library', price: 0 },
];
```

**`src/utils/highlight.tsx`**

```tsx
import { Fragment, ReactNode } from 'react';

export function highlight(text: string, query: string): ReactNode {
  const q = query.trim();
  if (!q) return text;

  const escaped = q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const re = new RegExp(`(${escaped})`, 'ig');
  const parts = text.split(re);
  return (
    <>
      {parts.map((part, i) =>
        re.test(part) ? <mark key={i}>{part}</mark> : <Fragment key={i}>{part}</Fragment>
      )}
    </>
  );
}
```

### 3-4) 입력/셀렉트 컴포넌트

**`src/components/SearchInput.tsx`** — `forwardRef`로 **DOM 포커스** 제어

```tsx
import { forwardRef } from 'react';

type Props = {
  value: string;
  onChange: (next: string) => void;
  placeholder?: string;
};

const SearchInput = forwardRef<HTMLInputElement, Props>(
  ({ value, onChange, placeholder }, ref) => {
    return (
      <input
        ref={ref}
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder ?? '검색어 입력'}
        style={{ flex: 1, padding: 8, borderRadius: 8, border: '1px solid #ddd' }}
        aria-label="검색 입력"
      />
    );
  }
);
SearchInput.displayName = 'SearchInput';
export default SearchInput;
```

**`src/components/CategorySelect.tsx`**

```tsx
type Props = {
  categories: Array<'all' | 'Framework' | 'Library' | 'Tool'>;
  value: 'all' | 'Framework' | 'Library' | 'Tool';
  onChange: (next: Props['value']) => void;
};

export default function CategorySelect({ categories, value, onChange }: Props) {
  return (
    <select
      value={value}
      onChange={(e) => onChange(e.target.value as Props['value'])}
      style={{ padding: 8, borderRadius: 8, border: '1px solid #ddd' }}
      aria-label="카테고리 선택"
    >
      {categories.map((c) => (
        <option key={c} value={c}>{c}</option>
      ))}
    </select>
  );
}
```

### 3-5) 결과 리스트 & 아이템 (메모이제이션)

**`src/components/ResultItem.tsx`** — `React.memo` + **렌더 카운터(Ref)**

```tsx
import { memo, useRef } from 'react';
import type { Item } from '../data';
import { highlight } from '../utils/highlight';

type Props = {
  item: Item;
  query: string;
  isFavorite: boolean;
  onToggleFavorite: (id: string) => void;
};

function ResultItemBase({ item, query, isFavorite, onToggleFavorite }: Props) {
  const renderCount = useRef(0);
  renderCount.current += 1;

  return (
    <li
      style={{
        border: '1px solid #eee', borderRadius: 12, padding: 12,
        display: 'grid', gap: 6, alignItems: 'start'
      }}
    >
      <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
        <strong>{highlight(item.name, query)}</strong>
        <span style={{ fontSize: 12, color: '#666' }}>#{item.category}</span>
        <span style={{ marginLeft: 'auto', fontSize: 12, color: '#999' }}>
          renders: {renderCount.current}
        </span>
      </div>

      <div style={{ display: 'flex', gap: 8 }}>
        <button
          onClick={() => onToggleFavorite(item.id)}
          aria-label="즐겨찾기 토글"
          style={{
            padding: '6px 10px', borderRadius: 8,
            border: '1px solid #ddd', background: isFavorite ? '#111' : '#fff',
            color: isFavorite ? '#fff' : '#111'
          }}
        >
          {isFavorite ? '★ 즐겨찾기' : '☆ 즐겨찾기'}
        </button>
      </div>
    </li>
  );
}

const ResultItem = memo(ResultItemBase);
export default ResultItem;
```

**`src/components/ResultsList.tsx`**

```tsx
import type { Item } from '../data';
import ResultItem from './ResultItem';

type Props = {
  items: Item[];
  query: string;
  favorites: Set<string>;
  onToggleFavorite: (id: string) => void;
};

export default function ResultsList({ items, query, favorites, onToggleFavorite }: Props) {
  if (items.length === 0) return <p style={{ color: '#777' }}>검색 결과가 없습니다.</p>;

  return (
    <ul style={{ listStyle: 'none', padding: 0, display: 'grid', gap: 10 }}>
      {items.map((it) => (
        <ResultItem
          key={it.id}
          item={it}
          query={query}
          isFavorite={favorites.has(it.id)}
          onToggleFavorite={onToggleFavorite}
        />
      ))}
    </ul>
  );
}
```

### 3-6) 컨테이너: `useMemo` / `useCallback` / `useRef` 총집합

**`src/components/SearchApp.tsx`**

```tsx
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { items as RAW } from '../data';
import SearchInput from './SearchInput';
import CategorySelect from './CategorySelect';
import ResultsList from './ResultsList';

type Category = 'all' | 'Framework' | 'Library' | 'Tool';

export default function SearchApp() {
  // 1) 검색/카테고리/즐겨찾기 상태
  const [rawQuery, setRawQuery] = useState('');  // 즉각 입력 반영
  const [query, setQuery] = useState('');        // 디바운스된 쿼리
  const [category, setCategory] = useState<Category>('all');
  const [favorites, setFavorites] = useState<Set<string>>(new Set());

  // 2) 입력 포커스(ref) + 디바운스 타이머(ref)
  const inputRef = useRef<HTMLInputElement>(null);
  const debounceRef = useRef<number | null>(null);

  useEffect(() => {
    inputRef.current?.focus(); // 마운트 시 1회 포커스
  }, []);

  const handleQueryChange = useCallback((next: string) => {
    setRawQuery(next);
    if (debounceRef.current) window.clearTimeout(debounceRef.current);
    debounceRef.current = window.setTimeout(() => setQuery(next), 200);
  }, []);

  // 3) 고정 데이터/카테고리 목록 메모(의존 없음)
  const items = RAW; // 실제 앱에선 서버/캐시에서 fetch
  const categories = useMemo<Category[]>(
    () => ['all', 'Framework', 'Library', 'Tool'],
    []
  );

  // 4) 비싼 계산(검색/필터) 메모
  const filtered = useMemo(() => {
    const q = query.trim().toLowerCase();
    return items.filter((it) => {
      const qOk =
        !q ||
        it.name.toLowerCase().includes(q);
      const cOk = category === 'all' || it.category === category;
      return qOk && cOk;
    });
  }, [items, query, category]);

  // 5) 안정적인 핸들러(참조 동일성) - memoized child와 궁합
  const toggleFavorite = useCallback((id: string) => {
    setFavorites((prev) => {
      const next = new Set(prev);
      next.has(id) ? next.delete(id) : next.add(id);
      return next;
    });
  }, []);

  return (
    <section style={{ maxWidth: 760, margin: '0 auto', padding: 24, display: 'grid', gap: 16 }}>
      <h1>고급 훅 — 검색 필터링 데모</h1>

      <div style={{ display: 'flex', gap: 8 }}>
        <SearchInput
          ref={inputRef}
          value={rawQuery}
          onChange={handleQueryChange}
          placeholder="예: react / next / vite"
        />
        <CategorySelect
          categories={categories}
          value={category}
          onChange={setCategory}
        />
      </div>

      <ResultsList
        items={filtered}
        query={query}
        favorites={favorites}
        onToggleFavorite={toggleFavorite}
      />
    </section>
  );
}
```

### 3-7) 진입점

**`src/App.tsx`**

```tsx
import SearchApp from './components/SearchApp';

export default function App() {
  return (
    <main style={{ fontFamily: 'system-ui', lineHeight: 1.5 }}>
      <SearchApp />
    </main>
  );
}
```

**`src/main.tsx`**

```tsx
import { createRoot } from 'react-dom/client';
import App from './App';
import './index.css';

createRoot(document.getElementById('root')!).render(<App />);
```

> 실행 포인트
>
> * **useRef**: 입력 포커스, 디바운스 타이머 보관, `ResultItem`의 **렌더 카운터**
> * **useMemo**: `filtered` 계산/카테고리 배열 메모
> * **useCallback**: `toggleFavorite`, `handleQueryChange` 참조 안정화 → `React.memo` 자식의 불필요 렌더 감소

---

## 4) 실습 미션 (Hands-on)

1. **정렬 추가**

   * 가격 오름/내림차순 토글을 추가하고 `useMemo`에서 정렬해 보세요(원본 배열 불변성 유지).

2. **하이라이트 개선**

   * `highlight`가 여러 단어(`react vite`)도 처리하도록 공백 분할 후 OR 매칭 정규식으로 확장.

3. **페이지네이션 + 스크롤 보존**

   * 페이지 이동 시 입력 포커스가 유지되도록 `useRef`/`useEffect`로 제어.

4. **자식 렌더 최적화 체감하기**

   * `ResultItem`의 `renders:` 숫자를 보며, `useCallback` 제거/복원 실험 → 어떤 경우에 **렌더 감소**가 일어나는지 팀 토론.

5. **가상 스크롤(선택)**

   * 아이템 1,000개로 늘려보고 느려지면 `react-window` 같은 virtualization 도입.

---

## 5) 자주 하는 실수 & 베스트 프랙티스

* **무분별한 `useMemo`/`useCallback`**: 값/함수가 가볍다면 오히려 오버헤드. **비싸거나 참조 안정성이 중요한 경우**만.
* **의존성 배열 누락**: `useMemo`/`useCallback`은 **참조 안정성 = 의존성 정확성**. ESLint(react-hooks) 규칙을 켜두세요.
* **Set/Map 상태 비교**: 레퍼런스가 바뀌어야 렌더됩니다. **새 인스턴스**를 반환하세요.
* **Debounce 누락 정리**: 타이머는 `useRef`에 보관하고 **언마운트 시 `clearTimeout`**(이 예제는 새 타이머 설정 시 이전 타이머를 즉시 정리).

---

## 6) 예상 질문(Q\&A)

**Q1. `useMemo`와 `useCallback`은 언제 쓰나요?**
A. **비싼 계산 결과 재사용**(`useMemo`), **자식에 넘길 핸들러 참조 고정**(`useCallback`). “렌더가 느리다/자식이 불필요하게 자주 렌더된다”가 관찰될 때 투입합니다.

**Q2. `React.memo`만으로 충분하지 않나요?**
A. 자식이 `React.memo`여도 **부모가 매번 새 핸들러/객체를 생성**하면 props 참조가 매번 달라져 리렌더됩니다. 이때 `useCallback`/`useMemo`가 도움 됩니다.

**Q3. `useRef`로 상태를 관리해도 되나요?**
A. “렌더에 반영되어야 하는 값”은 **state**로, “렌더와 무관하지만 유지해야 하는 값”은 **ref**로. UI에 보여야 하면 `useRef`가 아니라 `useState`를 쓰세요.

**Q4. 디바운스를 `useEffect`로 하기도 하던데요?**
A. 가능합니다. `rawQuery`가 변할 때 `useEffect` 내부에서 타이머를 설정/정리하는 방식도 일반적입니다. 이번 예제는 타이머 핸들을 **ref**로 관리했습니다.

**Q5. 메모이제이션이 역효과일 수 있나요?**
A. 네. 값이 싸고 변경이 잦다면 **메모 캐시 관리 비용**이 더 큽니다. 측정(Profiler/DevTools) 후 적용하세요.

